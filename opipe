#!/usr/bin/env bash

# cspell:ignore logfile jmor FEWC smso rmso civis rmcup smcup cnorm extglob patsub exitcode globasciiranges setaf ABDG SIGCHLD SIGTRAP SIGWINCH

# https://www.kylheku.com/cgit/basta/tree/basta.sh?id=7fbdc5a088c37bd24da5954474a189cd4c890dce
# https://www.kylheku.com/cgit/basta/about/

readonly ONE_CHAR_INPUT='false'
readonly DO_LOG='false'
readonly LOGFILE="$HOME/reposLocal/custom-shell-scripts/log.txt"
eval "$DO_LOG" && (echo -n $'\n' >> "$LOGFILE")
eval "$DO_LOG" && (date +'%T %D' >> "$LOGFILE")
# #region Signals
# https://man7.org/linux/man-pages/man7/signal.7.html
# readonly SIGTRAP=5
# readonly SIGCHLD=17
# readonly SIGWINCH=28
readonly SIGINT=2
readonly SIGQUIT=3
readonly SIGTERM=15
# #endregion Signals
readonly MAX_READ_INT=$(( 2**31 - 1))
readonly FAIL_TEXT="FAILURE"
# #region Patterns
readonly V_CTRL_STUB=$'\n\v\f'
readonly START_TEXT='

# Running:

'
declare START_PATTERN=''
if eval $ONE_CHAR_INPUT; then
	declare -r START_PATTERN="$START_TEXT\$"
else
	declare -r START_PATTERN="^(.*$START_TEXT)"
fi
readonly END_TEXT='

Finished in '
readonly END_PATTERN="${END_TEXT}[[:digit:].]+s, [[:digit:].]+ runs/s, [[:digit:].]+ assertions/s.
[[:digit:]]+ runs, [[:digit:]]+ assertions, [[:digit:]]+ failures, [[:digit:]]+ errors, [[:digit:]]+ skips[$V_CTRL_STUB]"
readonly STATUS_CHARACTERS='.FEWC'
readonly NL_STUB='[:print:][:blank:]'
readonly NL_PATTERN='[^[:print:][:blank:]]'
readonly NON_NL_PATTERN='[[:print:][:blank:]]'
readonly NON_NL_NOR_STATUS_CHARACTERS=$'[^\n\v\f.FEWC]' # readonly NON_NL_NOR_STATUS_CHARACTERS='[ABDG-VXYZa-z!-,/[:digit:][:blank:]]'
readonly PATTERN="^([$STATUS_CHARACTERS]+)((${NL_PATTERN}[^.]$NON_NL_PATTERN*)+$NL_PATTERN*)(.*)$"
# readonly PATTERN="^([$STATUS_CHARACTERS]+)(($NL_PATTERN+[$STATUS_CHARACTERS]*$NON_NL_NOR_STATUS_CHARACTERS$NON_NL_PATTERN*)+$NL_PATTERN*)(.*)$"
readonly STATUS_LINE_PATTERN="(^|$NL_PATTERN)([$STATUS_CHARACTERS]+)$"
# readonly STATUS_SEG_PATTERN="(^|$NL_PATTERN)([$STATUS_CHARACTERS]+)$NL_PATTERN+[$STATUS_CHARACTERS]+[^$STATUS_CHARACTERS]+.*"
readonly STATUS_SEG_PATTERN="(^|$NL_PATTERN)([$STATUS_CHARACTERS]+)$NL_PATTERN+[$STATUS_CHARACTERS]*$NON_NL_NOR_STATUS_CHARACTERS+.*"
# #endregion Patterns

# #region Print handler
# The last printed, non-vertical-whitespace character printed by `display_text`.
declare last_char=''
# declare -i last_col=0
declare last_status=''
declare -i current_color=7
declare -a print_instructions_colors=()
declare -a print_instructions_indices=()
# To account for end of line jank, jumps to the last character's position and rewrites it in a block with the new output (as this ensures proper word wrapping & window resizing).
# Depends on:
# 	cud1
# 	cuu1
# 	hpa
# 	el
# 	ed
# 	smso
# 	rmso
# 	cr
display_text() {
	local -r status_text="$1"
	# local -r whole_text="$2"
	# If there's a prior character, add it to the delta to redraw it.
	local delta=''
	if [[ -n "${last_char+x}" ]]; then
		local -r delta="$last_char$3"
	else
		local -r delta="$3"
	fi
	local -r prior_whole_text="$4"
	if ((${#last_status} > 0)); then
		tput hpa 0 el
		tput cuu1
		local -i t_statusRows=$(profile_text --display_mode -r "$last_status")
		while ((t_statusRows > 1)); do
			tput el cuu1
			((t_statusRows--))
		done
		tput hpa "$(profile_text --display_mode --col_at _ "$prior_whole_text")"
	fi
	if ((${#print_instructions_colors[@]} == 0)) || ((${#print_instructions_colors[@]} == 1)) && [[ "${print_instructions_colors[0]}" =~ ^-$|^$current_color$ ]]; then
		echo -n "$(tput setaf $current_color)$delta$(tput setaf 7)"
	else
		local t_d=''
		local -i t_last_index=0
		t_d+=$(tput setaf $current_color)
		if ((${#last_char}!=0)); then 
			t_d+=$(tput setaf $current_color)
			t_d+="${delta:$t_last_index:${#last_char}}"
			((t_last_index=${#last_char}))
		elif [ "${print_instructions_colors[0]}" = '-' ] || [ "${print_instructions_colors[0]}" = "$current_color" ]; then
			t_d+=$(tput setaf $current_color)
		fi
		for ((i=0; i < ${#print_instructions_colors[@]}; i++)); do
			t_d+="${delta:$t_last_index:$((${print_instructions_indices[$i]}+${#last_char}-t_last_index))}"
			if [ "${print_instructions_colors[$i]}" != '-' ]; then
				t_d+=$(tput setaf "${print_instructions_colors[$i]}")
				((current_color=${print_instructions_colors[$i]}))
			fi	
			((t_last_index=${print_instructions_indices[$i]}+${#last_char}))
			unset "print_instructions_indices[$i]"
			unset "print_instructions_colors[$i]"
		done
		if [ ${#print_instructions_colors[@]} != 0 ]; then echo "Not cleared; ${#print_instructions_colors[@]}: ${print_instructions_colors[*]}"; exit 1; fi
		if [ ${#print_instructions_indices[@]} != 0 ]; then echo "Not cleared; ${#print_instructions_indices[@]}: ${print_instructions_indices[*]}"; exit 1; fi
		t_d+="${delta:$t_last_index}"
		echo -n "$t_d$(tput setaf 7)"
	fi
	tput cud1
	tput cr
	eval $ONE_CHAR_INPUT && tput el
	tput smso
	echo -n "$status_text"
	tput rmso
	declare -g last_status=$status_text
	declare -g last_char="${delta: -1}"
	if [[ "$last_char" =~ [$V_CTRL_STUB] ]]; then unset last_char; fi
}
# #endregion Print handler
# #region modify_values & gen_status_text
# #1: Former color
# #2: New color
# #3: Index
add_instruction() {
	if (($1 == $2)); then
		if ((${#print_instructions_colors[@]} == 0)); then
			print_instructions_colors[0]="-"
			# ((print_instructions_counts[0]=1))
			((print_instructions_indices[0]=$3))
		# else
			# local -i instCount=${#print_instructions_counts[@]}
			# ((print_instructions_counts[$instCount]+=1))
			# local -i instCount=${#print_instructions_counts[@]}
			# ((print_instructions_indices[instCount]=))
		fi
	else
		print_instructions_colors+=("$2")
		# print_instructions_counts+=(1)
		print_instructions_indices+=("$3")
	fi
}
declare -i i_complete=0 i_successful=0 i_failure=0 i_error=0 i_warning=0 i_correction=0
# #1: text
# #2 (optional): - to subtract, anything else (other than an unsigned integer) to add
# ...: an index to skip + either the index to skip to (inclusive) or nothing to skip to the end.
function modify_values() {
	local -r appended="$1"
	shift
	if [ "$1" = "-" ]; then
		local -r operand="-"
	else
		local -r operand="+"
	fi
	while [[ -n "${1+x}" ]] && [[ "$1" =~ [^[:digit:]] ]]; do shift; done
	local -n target=i_successful
	local -i curr_color=$current_color
	local -i new_color=0
	if (( ${#print_instructions_colors[@]} != 0 )); then
		unset print_instructions_colors
		declare -g -a print_instructions_colors=()
	fi
	if (( ${#print_instructions_indices[@]} != 0 )); then
		unset print_instructions_indices
		declare -g -a print_instructions_indices=()
	fi
	for (( i=0; i < ${#appended}; i+=1 )); do
		if [[ -n "${1+x}" ]] && (($1 == i)); then
			add_instruction $curr_color 7 $i
			((curr_color=7))
			if [[ -n "${2+x}" ]]; then
				((i+=$2 - $1))
				shift 2
				continue
			else
				break
			fi
		fi
		case "${appended:$i:1}" in
			(F) local -n target=i_failure; ((new_color=1));;
			(E) local -n target=i_error; ((new_color=1));;
			(C) local -n target=i_correction; ((new_color=2));;
			(\.) local -n target=i_successful; ((new_color=2));;
			(W) local -n target=i_warning; ((new_color=3));;
			(*)
				local -n target=FAIL_TEXT
				echo "Something's wrong"
				;;
		esac
		if [ $target != $FAIL_TEXT ]; then
			# shellcheck disable=SC2091 disable=SC2271 disable=SC1105
			((target$operand=1))
			# shellcheck disable=SC2091 disable=SC2271 disable=SC1105
			((i_complete$operand=1))
			add_instruction $curr_color $new_color $i
			((curr_color=new_color))
		fi
	done
}
gen_status_text() {
	echo -n "Completed: $i_complete, .: $i_successful, F: $i_failure, E: $i_error, W: $i_warning, C: $i_correction"
}
# #endregion modify_values & gen_status_text
exec 3< <("$@")
declare -i -r sub_pid=$!
# #region Exit handling
is_active="true"
# is_killing="false"
do_stop() {
	# shellcheck disable=SC2317
	# if eval "$is_killing"; then
		kill -n "$1" "$sub_pid"
		# echo "Killing ($1)..."
	# else
		# echo "Is Killing ($1)..."
		# is_killing='true'
	# fi
	# shellcheck disable=SC2317
	exitcode=$(wait "$sub_pid")
	# wait "$sub_pid" && exitcode=$?
	# shellcheck disable=SC2317
	declare -i -r exitcode
	# shellcheck disable=SC2317
	# exec 3>&-
	# shellcheck disable=SC2317,SC2086,SC2064
	# exit $exitcode
	trap - INT
	# shellcheck disable=SC2317,SC2064
	trap - QUIT
	# shellcheck disable=SC2317,SC2064
	trap - TERM
}
# shellcheck disable=SC2064
trap "do_stop $SIGINT" INT
# shellcheck disable=SC2064
trap "do_stop $SIGQUIT" QUIT
# shellcheck disable=SC2064
trap "do_stop $SIGTERM" TERM
# #endregion Exit handling
# #region Input loop
declare -i c_iterations=0; declare -i start_int=0
readonly extglob_off=$( if [[ $(shopt extglob) =~ on$ ]]; then echo 'false'; else echo 'true'; fi )
readonly globasciiranges_off=$( if [[ $(shopt globasciiranges) =~ on$ ]]; then echo 'false'; else echo 'true'; fi )
readonly patsub_replacement_off=$( if [[ $(shopt patsub_replacement) =~ on$ ]]; then echo 'false'; else echo 'true'; fi )
tput sc
tput civis
# trap 'tput rc; tput cnorm' EXIT
status_text="WAITING..."
cumulative=""
line=""
out_pipe() {
	if eval $ONE_CHAR_INPUT; then
		read -s -r -N 1 -u 3 line
	else
		read -s -r -t .3 -N $MAX_READ_INT -u 3 line
	fi
}
while eval $is_active; do
	((c_iterations+=1))
	out_pipe
	eval "$DO_LOG" && (echo "Newest input (raw): $line" >> "$LOGFILE")
	if [ -z "$line" ]; then
		if kill -0 $sub_pid > /dev/null 2>&1; then
			line=''
		else
			is_active="false"
			if [[ -z "${exitcode+x}" ]]; then wait $sub_pid && declare -ir exitcode; fi
		fi
	fi
	if eval $is_active && [ -n "$line" ]; then
		t_prior="$cumulative"
		cumulative+="$line"
		if ((start_int != 0)); then
			if eval "$extglob_off"; then shopt -s extglob; fi
			if eval "$globasciiranges_off"; then shopt -s globasciiranges; fi
			if eval "$patsub_replacement_off"; then shopt -s patsub_replacement; fi
			results_string="${cumulative:start_int}"
			eval "$DO_LOG" && (echo "$results_string" >> "$LOGFILE")
			# if eval $ONE_CHAR_INPUT; then
				if [[ "$results_string" =~ $STATUS_LINE_PATTERN ]]; then
					modify_values "$line"
				elif [[ "${results_string:0:-1}" =~ $STATUS_LINE_PATTERN ]] && [ "${results_string: -1:1}" != $'\n' ]; then
					modify_values "${BASH_REMATCH[2]}" '-'
				fi
			# TODO: Finish status line parsing for multi-char input
			# else
			# 	if [[ "$results_string" =~ $STATUS_SEG_PATTERN ]]; then
			# 		modify_values "$line"
			# 	elif [[ "${results_string:0:-1}" =~ $STATUS_SEG_PATTERN ]] && [ "${results_string: -1:1}" != $'\n' ]; then
			# 		modify_values "${BASH_REMATCH[2]}" '-'
			# 	fi
			# fi
			if eval "$extglob_off"; then shopt -u extglob; fi
			if eval "$globasciiranges_off"; then shopt -u globasciiranges; fi
			if eval "$patsub_replacement_off"; then shopt -u patsub_replacement; fi
			status_text="$(gen_status_text)"
			eval "$DO_LOG" && (echo "$status_text" >> "$LOGFILE")
		elif [[ $cumulative =~ $START_PATTERN ]]; then
			if eval $ONE_CHAR_INPUT; then
				start_int=${#cumulative}
			else
				start_int=${#BASH_REMATCH[1]}
			fi
			declare -i -r start_int
		fi
		display_text "$status_text" "$cumulative" "$line" "$t_prior"
	fi
done
# #endregion Input loop
if [[ -z "${exitcode+x}" ]]; then wait $sub_pid && declare -ir exitcode; fi
tput rc
tput cnorm ed
exec 3>&-
output="Exitcode: $exitcode
Iterations: $c_iterations
start_int: $start_int
Cumulative length: ${#cumulative}
Cumulative output:
$cumulative"
echo "$output"
eval "$DO_LOG" && (echo "$output" >> "$LOGFILE")
exit