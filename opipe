#!/usr/bin/env bash

# cspell:ignore logfile jmor FEWC smso rmso civis rmcup smcup cnorm extglob patsub exitcode globasciiranges setaf ABDG SIGCHLD SIGTRAP SIGWINCH

# https://www.kylheku.com/cgit/basta/tree/basta.sh?id=7fbdc5a088c37bd24da5954474a189cd4c890dce
# https://www.kylheku.com/cgit/basta/about/

readonly ONE_CHAR_INPUT='false'
readonly DO_LOG='false'
readonly LOGFILE="$HOME/reposLocal/custom-shell-scripts/log.txt"
eval "$DO_LOG" && (echo -n $'\n' >> "$LOGFILE")
eval "$DO_LOG" && (date +'%T %D' >> "$LOGFILE")
# #region Signals
# https://man7.org/linux/man-pages/man7/signal.7.html
# readonly SIGTRAP=5
# readonly SIGCHLD=17
# readonly SIGWINCH=28
readonly SIGINT=2
readonly SIGQUIT=3
readonly SIGTERM=15
# #endregion Signals
readonly MAX_READ_INT=$(( 2**31 - 1))
readonly -i DEFAULT_COLOR_FOREGROUND=7
readonly FAIL_TEXT="FAILURE"
# #region Patterns
readonly V_CTRL_STUB=$'\n\v\f'
readonly START_TEXT='

# Running:

'
declare START_PATTERN=''
if eval $ONE_CHAR_INPUT; then
	declare -r START_PATTERN="$START_TEXT\$"
else
	declare -r START_PATTERN="^(.*$START_TEXT)"
fi
readonly END_TEXT='

Finished in '
readonly END_PATTERN="${END_TEXT}[[:digit:].]+s, [[:digit:].]+ runs/s, [[:digit:].]+ assertions/s.
[[:digit:]]+ runs, [[:digit:]]+ assertions, [[:digit:]]+ failures, [[:digit:]]+ errors, [[:digit:]]+ skips[$V_CTRL_STUB]"
readonly STATUS_CHARACTERS='.FEWC'
readonly STATUS_CHARACTERS_PATTERN='[.FEWC]'
readonly NL_STUB='[:print:][:blank:]'
readonly NL_PATTERN='[^[:print:][:blank:]]'
readonly NON_NL_PATTERN='[[:print:][:blank:]]'
readonly NON_NL_NOR_STATUS_CHARACTERS=$'[^\n\v\f.FEWC]' # readonly NON_NL_NOR_STATUS_CHARACTERS='[ABDG-VXYZa-z!-,/[:digit:][:blank:]]'
readonly PATTERN="^([$STATUS_CHARACTERS]+)((${NL_PATTERN}[^.]$NON_NL_PATTERN*)+$NL_PATTERN*)(.*)$"
# readonly PATTERN="^([$STATUS_CHARACTERS]+)(($NL_PATTERN+[$STATUS_CHARACTERS]*$NON_NL_NOR_STATUS_CHARACTERS$NON_NL_PATTERN*)+$NL_PATTERN*)(.*)$"
readonly STATUS_LINE_PATTERN="(^|$NL_PATTERN)([$STATUS_CHARACTERS]+)$"
readonly STATUS_LINE_START="^($NL_PATTERN*)([$STATUS_CHARACTERS]+)($|$NL_PATTERN)"
readonly SL_START_CLEAN="^($NL_PATTERN+)([$STATUS_CHARACTERS]+)($|$NL_PATTERN+)"
readonly SL_CHUNKER="^($NL_PATTERN*)(([$STATUS_CHARACTERS]+)|($NON_NL_PATTERN*))($|$NL_PATTERN+)"
readonly STATUS_CHUNK_PATTERN="(^|$NL_PATTERN)([$STATUS_CHARACTERS]+)($|$NL_PATTERN+.*$)"
readonly SL_TRAILING_PATTERN="(^|$NL_PATTERN)([$STATUS_CHARACTERS]+)$"
readonly SL_LEADING_NOT_PATTERN="^[$STATUS_CHARACTERS]*$NON_NL_NOR_STATUS_CHARACTERS"
# readonly STATUS_SEG_PATTERN="(^|$NL_PATTERN)([$STATUS_CHARACTERS]+)$NL_PATTERN+[$STATUS_CHARACTERS]+[^$STATUS_CHARACTERS]+.*"
readonly STATUS_SEG_PATTERN="(^|$NL_PATTERN)([$STATUS_CHARACTERS]+)$NL_PATTERN+[$STATUS_CHARACTERS]*$NON_NL_NOR_STATUS_CHARACTERS+.*"
# #endregion Patterns

# #region Print handler
# The last printed, non-vertical-whitespace character printed by `display_text`.
# declare last_char=''
# The last printed section of the main output printed by `display_text`.
declare last_delta=''
# The last status text printed by `display_text`; used to determine how many lines to shift up in the next iteration.
declare last_status=''
declare -i current_color=$DEFAULT_COLOR_FOREGROUND
declare -a print_instructions_colors=()
declare -a print_instructions_indices=()
# To account for end of line jank, jumps to the last character's position and rewrites it in a block with the new output (as this ensures proper word wrapping & window resizing).
# Depends on:
# 	cud1
# 	cuu1
# 	hpa
# 	el
# 	ed
# 	smso
# 	rmso
# 	cr
display_text() {
	local -r status_text="$1"
	# local -r whole_text="$2"
	# If there's a prior character, add it to the delta to redraw it.
	local delta=''
	local last_char="${last_delta: -1}"
	if [[ "$last_char" =~ [$V_CTRL_STUB] ]]; then unset last_char; else local -r last_char; fi
	if [[ -n "${last_char+x}" ]]; then
		local -r delta="$last_char$3"
	else
		local -r delta="$3"
	fi
	local -r prior_whole_text="$4"
	if ((${#last_status} > 0)); then
		tput hpa 0 el
		tput cuu1
		local -i t_statusRows=$(profile_text --display_mode -r "$last_status")
		while ((t_statusRows > 1)); do
			tput el cuu1
			((t_statusRows--))
		done
		tput hpa "$(profile_text --display_mode --col_at _ "$prior_whole_text")"
	fi
	if ((${#print_instructions_colors[@]} == 0)) || ((${#print_instructions_colors[@]} == 1)) && [[ "${print_instructions_colors[0]}" =~ ^-$|^$current_color$ ]]; then
		echo -n "$(tput setaf $current_color)$delta$(tput setaf $DEFAULT_COLOR_FOREGROUND)"
	else
		local t_d=''
		local -i t_last_index=0
		t_d+=$(tput setaf $current_color)
		if ((${#last_char}!=0)); then
			t_d+=$(tput setaf $current_color)
			t_d+="${delta:$t_last_index:${#last_char}}"
			((t_last_index=${#last_char}))
		elif [ "${print_instructions_colors[0]}" = '-' ] || [ "${print_instructions_colors[0]}" = "$current_color" ]; then
			t_d+=$(tput setaf $current_color)
		fi
		for ((i=0; i < ${#print_instructions_colors[@]}; i++)); do
			t_d+="${delta:$t_last_index:$((${print_instructions_indices[$i]}+${#last_char}-t_last_index))}"
			if [ "${print_instructions_colors[$i]}" != '-' ]; then
				t_d+=$(tput setaf "${print_instructions_colors[$i]}")
				((current_color=${print_instructions_colors[$i]}))
			fi	
			((t_last_index=${print_instructions_indices[$i]}+${#last_char}))
			unset "print_instructions_indices[$i]"
			unset "print_instructions_colors[$i]"
		done
		if [ ${#print_instructions_colors[@]} != 0 ]; then echo "Not cleared; ${#print_instructions_colors[@]}: ${print_instructions_colors[*]}"; exit 1; fi
		if [ ${#print_instructions_indices[@]} != 0 ]; then echo "Not cleared; ${#print_instructions_indices[@]}: ${print_instructions_indices[*]}"; exit 1; fi
		t_d+="${delta:$t_last_index}"
		echo -n "$t_d$(tput setaf $DEFAULT_COLOR_FOREGROUND)"
	fi
	tput cud1
	tput cr
	eval $ONE_CHAR_INPUT && tput el
	tput smso
	echo -n "$status_text"
	tput rmso
	declare -g last_status="$status_text"
	declare -g last_delta="$delta"
	# declare -g last_char="${delta: -1}"
	# if [[ "$last_char" =~ [$V_CTRL_STUB] ]]; then unset last_char; fi
}
# #endregion Print handler
# #region modify_values & gen_status_text
# #1: Former color
# #2: New color
# #3: Index
add_instruction() {
	if (($1 != $2)); then
		print_instructions_colors+=("$2")
		print_instructions_indices+=("$3")
	# else
	# 	if ((${#print_instructions_colors[@]} == 0)); then
	# 		print_instructions_colors[0]="-"
	# 		((print_instructions_indices[0]=$3))
	# 	fi
	fi
}
declare -i i_complete=0 i_successful=0 i_failure=0 i_error=0 i_warning=0 i_correction=0
# #1: text
# #2 (optional): - to subtract, anything else (other than an unsigned integer) to add
# #3 (optional; -[[:digit:]]+): the index to start processing on; 0 if omitted
# ...: an index to skip + either the index to skip to (inclusive) or nothing to skip to the end.
function modify_values() {
	# P1
	local -r appended="$1"; shift
	# #region P2
	local operand="+"
	case "$1" in
		-)  local -r operand="-";;
		\+) local -r operand="+";;
		*) ;;
			# echo "2nd arg must be +/-; was $1"
			# exit 127
			# ;;
	esac
	while [[ -n "${1+x}" ]] && [[ "$1" =~ -?[^[:digit:]] ]]; do shift; done
	# #endregion P2
	# #region P3
	local -i l_offset=0
	if [[ "$1" =~ ^-[[:digit:]]+$ ]]; then l_offset="${1:1}"; shift; fi
	local -r l_offset
	# #endregion P3
	local -n target=i_successful
	local -i curr_color=$current_color
	local -i new_color=0
	if (( ${#print_instructions_colors[@]} != 0 )); then
		unset print_instructions_colors
		declare -g -a print_instructions_colors=()
	fi
	if (( ${#print_instructions_indices[@]} != 0 )); then
		unset print_instructions_indices
		declare -g -a print_instructions_indices=()
	fi
	for (( i=l_offset; i < ${#appended}; i+=1 )); do
		if [[ -n "${1+x}" ]] && (($1 <= i)); then
			add_instruction $curr_color $DEFAULT_COLOR_FOREGROUND $i
			((curr_color=DEFAULT_COLOR_FOREGROUND))
			if [[ -n "${2+x}" ]]; then
				((i += i < $2 ? $2 - $i : 0))
				shift 2
				continue
			else
				break
			fi
		fi
		if [[ "${appended:$i}" =~ ^$NL_PATTERN*([$STATUS_CHARACTERS]*$NON_NL_NOR_STATUS_CHARACTERS+$NON_NL_PATTERN*)($NL_PATTERN*) ]]; then
			add_instruction $curr_color $DEFAULT_COLOR_FOREGROUND $i
			((curr_color=DEFAULT_COLOR_FOREGROUND))
			if ((${#BASH_REMATCH[2]} > 0)); then
				((i+=${#BASH_REMATCH[0]} - 1))
				continue
			else
				break
			fi
		fi
		case "${appended:$i:1}" in
			(F) local -n target=i_failure; ((new_color=1));;
			(E) local -n target=i_error; ((new_color=1));;
			(C) local -n target=i_correction; ((new_color=2));;
			(\.) local -n target=i_successful; ((new_color=2));;
			(W) local -n target=i_warning; ((new_color=3));;
			(*)
				local -n target=FAIL_TEXT
				# add_instruction $curr_color $DEFAULT_COLOR_FOREGROUND $i
				# ((curr_color=DEFAULT_COLOR_FOREGROUND))
				# if [[ "${appended:$i}" =~ ^$NL_PATTERN*([$STATUS_CHARACTERS]*$NON_NL_NOR_STATUS_CHARACTERS+$NON_NL_PATTERN*)$NL_PATTERN+ ]]; then
				# 	((i+=${#BASH_REMATCH[0]} - 1))
				# 	shift 2
				# 	continue
				# else
				# 	break
				# fi
				echo "Something's wrong"
				;;
		esac
		if [ $target != $FAIL_TEXT ]; then
			# shellcheck disable=SC2091 disable=SC2271 disable=SC1105
			((target$operand=1))
			# shellcheck disable=SC2091 disable=SC2271 disable=SC1105
			((i_complete$operand=1))
			add_instruction $curr_color $new_color $i
			((curr_color=new_color))
		fi
	done
	exit $curr_color
}
gen_status_text() {
	echo -n "Completed: $i_complete, .: $i_successful, F: $i_failure, E: $i_error, W: $i_warning, C: $i_correction"
}
# #endregion modify_values & gen_status_text
exec 3< <("$@")
declare -i -r sub_pid=$!
# #region Exit handling
is_active="true"
do_stop() {
	# shellcheck disable=SC2317
		kill -n "$1" "$sub_pid"
		kill -n "$1" "$sub_pid"
		# echo "Killing ($1)..."
	# else
		# echo "Is Killing ($1)..."
		# is_killing='true'
	# fi
	kill -n "$1" "$sub_pid"
		# echo "Killing ($1)..."
	# else
		# echo "Is Killing ($1)..."
		# is_killing='true'
	# fi
	# shellcheck disable=SC2317
	exitcode=$(wait "$sub_pid")
	# wait "$sub_pid" && exitcode=$?
	# shellcheck disable=SC2317
	declare -i -r exitcode
	# shellcheck disable=SC2317
	# exec 3>&-
	# shellcheck disable=SC2317,SC2086,SC2064
	# exit $exitcode
	trap - INT
	# shellcheck disable=SC2317,SC2064
	trap - QUIT
	# shellcheck disable=SC2317,SC2064
	trap - TERM
}
# shellcheck disable=SC2064
trap "do_stop $SIGINT" INT
# shellcheck disable=SC2064
trap "do_stop $SIGQUIT" QUIT
# shellcheck disable=SC2064
trap "do_stop $SIGTERM" TERM
# #endregion Exit handling
# #region Input loop
declare -i c_iterations=0; declare -i start_int=0
readonly extglob_off=$( if [[ $(shopt extglob) =~ on$ ]]; then echo 'false'; else echo 'true'; fi )
readonly globasciiranges_off=$( if [[ $(shopt globasciiranges) =~ on$ ]]; then echo 'false'; else echo 'true'; fi )
readonly patsub_replacement_off=$( if [[ $(shopt patsub_replacement) =~ on$ ]]; then echo 'false'; else echo 'true'; fi )
tput sc
tput civis
# trap 'tput rc; tput cnorm' EXIT
status_text="WAITING..."
cumulative=""
line=""
out_pipe() {
	if eval $ONE_CHAR_INPUT; then
		read -s -r -N 1 -u 3 line
	else
		read -s -r -t .3 -N $MAX_READ_INT -u 3 line
	fi
}
while eval $is_active; do
	((c_iterations+=1))
	out_pipe
	eval "$DO_LOG" && (echo "Newest input (raw): $line" >> "$LOGFILE")
	if [ -z "$line" ]; then
		if kill -0 $sub_pid > /dev/null 2>&1; then
			line=''
		else
			is_active="false"
			if [[ -z "${exitcode+x}" ]]; then wait $sub_pid && declare -ir exitcode; fi
		fi
	fi
	if eval $is_active && [ -n "$line" ]; then
		t_prior="$cumulative"
		cumulative+="$line"
		if ((start_int != 0)); then
			if eval "$extglob_off"; then shopt -s extglob; fi
			if eval "$globasciiranges_off"; then shopt -s globasciiranges; fi
			if eval "$patsub_replacement_off"; then shopt -s patsub_replacement; fi
			results_string="${cumulative:start_int}"
			eval "$DO_LOG" && (echo "$results_string" >> "$LOGFILE")
			if eval $ONE_CHAR_INPUT; then
				if [[ "$results_string" =~ $STATUS_LINE_PATTERN ]]; then
					modify_values "$line" '+'
				elif [[ "${results_string:0:-1}" =~ $STATUS_LINE_PATTERN ]] && [ "${results_string: -1:1}" != $'\n' ]; then
					modify_values "${BASH_REMATCH[2]}" '-'
				fi
			# TODO: Finish status line parsing for multi-char input
			else
				# declare -i t_o=0
				# for ((t_o=0, t_inc=0; t_o < ${#line}; t_o+="${#BASH_REMATCH[0]}", t_inc=1)); do
				# if [[ "${line:$((t_o-t_inc))}" =~ $SL_CHUNKER ]]; then
				# 	if [[ -n "${BASH_REMATCH[3]+x}" ]]; then
				# 		command ...
				# 	fi
				# 	if (("${#BASH_REMATCH[1]}" > 0)); then
				# 		modify_values "${line:$t_o}" '+' "-$t_o"
				# 	fi
				# fi
				# if [[ "${line:$t_o}" =~ $SL_START_CLEAN ]] then
				# 	if [ "${BASH_REMATCH[0]}" = "${line:$t_o}" ] then
				# 		modify_values "${line:$t_o}" '+' "-$t_o"
				# 	elif [ "${#BASH_REMATCH[2]}" = "${line:$t_o}" ]
						
				# 	fi
				# elif [[ "$line" =~ $STATUS_SEG_PATTERN ]] && [[ "$t_prior" =~ (^|$NL_PATTERN)($NON_NL_PATTERN*)$ ]] && [[ "${BASH_REMATCH[2]}" =~ ^[$STATUS_CHARACTERS]*$ ]]; then
				# 	modify_values "$line" '+'
				# elif [[ "${line:0:-1}" =~ $STATUS_SEG_PATTERN ]] && [ "${line: -1:1}" != $'\n' ]; then
				# 	modify_values "${BASH_REMATCH[2]}" '-'
				# fi
				# done
				if [[ "$line" =~ $SL_LEADING_NOT_PATTERN ]]; then
					if [[ "$t_prior" =~ $SL_TRAILING_PATTERN ]]; then
						modify_values "${BASH_REMATCH[2]}" '-' 
					fi
				fi
				modify_values "$line"
				# if [[ "$t_prior" =~ $SL_TRAILING_PATTERN ]]; then
				# 	# declare -r -a MATCH_CACHE=$(mapfile ) #(${BASH_REMATCH[@]})
				# 	mapfile -t MATCH_CACHE <<< "${BASH_REMATCH[@]}"
				# 	declare -r -a MATCH_CACHE #=$(mapfile ) #(${BASH_REMATCH[@]})
				# fi
			fi
			if eval "$extglob_off"; then shopt -u extglob; fi
			if eval "$globasciiranges_off"; then shopt -u globasciiranges; fi
			if eval "$patsub_replacement_off"; then shopt -u patsub_replacement; fi
			status_text="$(gen_status_text)"
			eval "$DO_LOG" && (echo "$status_text" >> "$LOGFILE")
		elif [[ $cumulative =~ $START_PATTERN ]]; then
			if eval $ONE_CHAR_INPUT; then
				start_int=${#cumulative}
			else
				start_int=${#BASH_REMATCH[1]}
			fi
			declare -i -r start_int
		fi
		display_text "$status_text" "$cumulative" "$line" "$t_prior"
	fi
done
# #endregion Input loop
if [[ -z "${exitcode+x}" ]]; then wait $sub_pid && declare -ir exitcode; fi
tput rc
tput cnorm ed
exec 3>&-
output="Exitcode: $exitcode
Iterations: $c_iterations
start_int: $start_int
Cumulative length: ${#cumulative}
Cumulative output:
$cumulative"
echo "$output"
eval "$DO_LOG" && (echo "$output" >> "$LOGFILE")
exit