#!/usr/bin/env bash

# cspell:ignore logfile jmor FEWC smso rmso civis rmcup smcup cnorm extglob patsub exitcode

# https://www.kylheku.com/cgit/basta/tree/basta.sh?id=7fbdc5a088c37bd24da5954474a189cd4c890dce
# https://www.kylheku.com/cgit/basta/about/

readonly ONE_CHAR_INPUT='false'
readonly MULTI_CHAR_INPUT="! $ONE_CHAR_INPUT"
readonly DO_LOG='false'
readonly LOGFILE='/home/jmor/reposLocal/custom-shell-scripts/log.txt'
eval "$DO_LOG" && (echo -n $'\n' >> $LOGFILE)
eval "$DO_LOG" && (date +'%T %D' >> $LOGFILE)
# #region Signals
# https://man7.org/linux/man-pages/man7/signal.7.html
# readonly SIGHUP=1
# readonly SIGTRAP=5
# readonly SIGABRT=6
# readonly SIGKILL=9
# readonly SIGSTKFLT=16
# readonly SIGCHLD=17
# readonly SIGCONT=18
# readonly SIGSTOP=19
# readonly SIGTSTP=20
# readonly SIGTTIN=21
# readonly SIGTTOU=22
# readonly SIGPROF=27
# readonly SIGWINCH=28
readonly SIGINT=2
readonly SIGQUIT=3
readonly SIGTERM=15
# #endregion Signals
declare -r -i MAX_READ_INT=$(( 2**31 - 1))
readonly FAIL_TEXT="FAILURE"
# #region Patterns
readonly START_TEXT='

# Running:

'
if eval $ONE_CHAR_INPUT; then
	readonly START_PATTERN="$START_TEXT\$"
else
	readonly START_PATTERN="^(.*$START_TEXT)"
fi
readonly END_TEXT='

Finished in '
readonly STATUS_CHARACTERS='.FEWC'
readonly NL_STUB='[:print:][:blank:]'
readonly NL_PATTERN='[^[:print:][:blank:]]'
readonly NON_NL_PATTERN='[[:print:][:blank:]]'
readonly NON_NL_NOR_STATUS_CHARACTERS="[ABDG-VXYZa-z!-,/[:digit:][:blank:]]"
readonly PATTERN="^([$STATUS_CHARACTERS]+)((${NL_PATTERN}[^.]$NON_NL_PATTERN*)+$NL_PATTERN*)(.*)$"
# readonly PATTERN="^([$STATUS_CHARACTERS]+)(($NL_PATTERN+[$STATUS_CHARACTERS]*$NON_NL_NOR_STATUS_CHARACTERS$NON_NL_PATTERN*)+$NL_PATTERN*)(.*)$"
readonly STATUS_LINE_PATTERN="(^|$NL_PATTERN)([$STATUS_CHARACTERS]+)$"
readonly STATUS_SEG_PATTERN="(^|$NL_PATTERN)([$STATUS_CHARACTERS]+)$NL_PATTERN+[$STATUS_CHARACTERS]+[^$STATUS_CHARACTERS]+.*"
# #endregion Patterns

# declare -i last_row=$(cursor_pos -r) LINES=$(tput lines)
# declare -i cum_stat_rows=0; declare -i cum_stat_line_offset=0
# declare -i prior_stat_rows=0; #declare f_overflow_mode='false'
declare cached_delta
declare -i cached_col=0
display_text() {
	local -r text="$1"
	local -r whole_text="$2"
	if [[ -n "${cached_delta+x}" ]]; then
		local -r delta="$cached_delta$3"
	else
		local -r delta="$3"
	fi
	local -r prior="$4"
	# eval $ONE_CHAR_INPUT && tput el
	# eval "$MULTI_CHAR_INPUT" && tput ed
	echo -n "$delta"
	# tput sc
	# eval $ONE_CHAR_INPUT &&  tput el
	# declare t="$(profile_text --row_at _ --no_trailing_control --initial_line_offset $cum_stat_line_offset "$delta")"
	# ((cum_stat_rows+=$(profile_text -r --initial_line_offset $cum_stat_line_offset "$delta"), cum_stat_line_offset=${#t}))
	# local -i t_prior_rows=$prior_stat_rows
	# if (("$(profile_text -r "$whole_text")"+init_row > $(tput lines))); then
	# if ((prior_stat_rows="$(profile_text -r "$whole_text")", t_prior_rows < prior_stat_rows)) && ((prior_stat_rows+init_row >= $(tput lines))); then
	# if (("$(profile_text -r "$whole_text")"+init_row >= $(tput lines))); then
	# if ((prior_stat_rows="$(profile_text -r --edit_mode "$whole_text")", t_prior_rows < prior_stat_rows)) && ((prior_stat_rows+init_row >= $(tput lines))); then
	# ((tput_lines=$(tput lines), tput_cols=$(tput cols), t_text_count=${#text} > 0 && ${#text} % tput_cols > 0 ? ${#text} : ${#text} - 1))
	# local was_true='false'
	# if ((prior_stat_rows="$(profile_text --display-mode -r "$whole_text")", t_prior_rows < prior_stat_rows)) && ((tput_lines=$(tput lines), tput_cols=$(tput cols), t_text_count=${#text} <= 0 || ${#text} % tput_cols > 0 ? ${#text} : ${#text} - 1, prior_stat_rows+init_row > tput_lines-1-t_text_count/tput_cols)) && [ "${delta: -1}" != $'\n' ]; then
	# 	was_true='true'
	# 	# tput sc
	# 	((t="$(profile_text --col_at _ "$whole_text")"))
	# 	if ((t == 1)); then
	# 		tput cud1
	# 	fi
	# 	tput cud1
	# 	# tput rc
	# 	tput cuu1
	# 	# echo -n $'\r'
	# 	if ((t > 0)); then
	# 		# tput cuf "$t"
	# 		tput hpa $((t - 1))
	# 	# elif profile_text --row_succeeded_by -1 "$STATUS_LINE_PATTERN" --trailing_control && [ ${delta:0:1} != $'\n' ]; then
	# 	# 	tput hpa "$tput_cols"
	# 	else
	# 		tput hpa 0
	# 	fi
	# 	# tput hpa "$(profile_text --edit_mode --col_at _ "$whole_text")"
	# 	unset t
	# fi
	# if (($(profile_text --display_mode --col_at _ "$prior") + $(profile_text --trailing_control --display_mode --col_at 0 "$delta") >= $(tput cols))); then
	# 	declare -g cached_delta="${prior: -1}"
	# else
	# 	unset cached_delta
	# fi
	# tput sc
	# declare -i -g cached_col
	# ((cached_col=$(profile_text --display_mode --col_at _ "$whole_text")))
	tput cud1
	tput cr
	eval $ONE_CHAR_INPUT && tput el
	tput smso
	# if eval $was_true; then echo -n "TRUE $text"; else echo -n "$text"; fi
	echo -n "$text"
	tput rmso
	# last_row=$(cursor_pos -r)
	# LINES=$(tput lines)
	# cached_delta="$delta"
	# tput rc
	tput cuu1
	# if [ "${prior: -1}" != $'\n' ]; then ((cached_col+=1)); fi
	tput hpa $(($(profile_text --display_mode --col_at _ "$whole_text")))
	# if (("$(profile_text -r "$whole_text")"+init_row >= $(tput lines))); then
	# 	tput cuu1
	# fi
	# if (($(profile_text --display_mode --col_at _ "$prior") + $(profile_text --no_trailing_control --display_mode --col_at 0 "$delta") >= $(tput cols))); then
	declare -g cached_delta="${delta: -1}"
	if [ "$cached_delta" == $'\n' ]; then unset cached_delta; fi
	# else
	# 	unset cached_delta
	# fi
}
cumulative=""
line=""
exec 3< <("$@")
declare -i -r sub_pid=$!
out_pipe() {
	if eval $ONE_CHAR_INPUT; then
		read -s -r -N 1 -u 3 line
	else
		read -s -r -t .3 -N $MAX_READ_INT -u 3 line
	fi
}
# #region Exit handling
is_active="true"
is_killing="false"
do_stop() {
	# shellcheck disable=SC2317
	if eval "$is_killing"; then
		kill -n "$1" "$sub_pid"
		echo "Killing ($1)..."
	else
		echo "Is Killing ($1)..."
		is_killing='true'
	fi
	# shellcheck disable=SC2317
	exitcode=$(wait "$sub_pid")
	# shellcheck disable=SC2317
	declare -i -r exitcode
	# shellcheck disable=SC2317
	exec 3>&-
	# shellcheck disable=SC2317,SC2086
	exit $exitcode
}
# shellcheck disable=SC2064
trap "do_stop $SIGINT" INT
# shellcheck disable=SC2064
trap "do_stop $SIGQUIT" QUIT
# shellcheck disable=SC2064
trap "do_stop $SIGTERM" TERM
# #endregion Exit handling
# #region modify_values & gen_status_text
declare -i c_complete=0 c_successful=0 c_failure=0 c_error=0 c_warning=0
function modify_values() {
	local -r appended="$1"
	local -i i
	if [ "$2" = "-" ]; then
		local -r operand="-"
	else
		local -r operand="+"
	fi
	local -n target=c_successful
	for (( i=0; i < ${#appended}; i+=1 )); do
		case "${appended:$i:1}" in
			(F) local -n target=c_failure;;
			(E) local -n target=c_error;;
			(W) local -n target=c_warning;;
			(\.) local -n target=c_successful;;
			(*)
				local -n target=FAIL_TEXT
				echo "Something's wrong"
				;;
		esac
		if [ $target != $FAIL_TEXT ]; then
			# shellcheck disable=SC2091 disable=SC2271 disable=SC1105
			((target$operand=1))
			# shellcheck disable=SC2091 disable=SC2271 disable=SC1105
			((c_complete$operand=1))
		fi
	done
}
gen_status_text() {
	# echo -n "Completed: $c_complete, Successful: $c_successful, Failures: $c_failure, Errors: $c_error, Warnings: $c_warning"
	echo -n ".: $c_complete, S: $c_successful, F: $c_failure, E: $c_error, W: $c_warning"
}
# #endregion modify_values & gen_status_text
declare -i c_iterations=0; declare -i start_int=0
readonly patsub_replacement_off=$( if [[ $(shopt patsub_replacement) =~ on$ ]]; then echo 'false'; else echo 'true'; fi )
readonly extglob_off=$( if [[ $(shopt extglob) =~ on$ ]]; then echo 'false'; else echo 'true'; fi )
tput sc
tput civis
# tput smcup
# trap 'tput rc;tput rmcup' EXIT
# trap 'tput rc; tput cnorm' EXIT
status_text="WAITING..."
init_row=$(cursor_pos -r)
while eval $is_active; do
	# last_row=$(cursor_pos -r)
	# LINES=$(tput lines)
	((c_iterations+=1))
	out_pipe
	eval "$DO_LOG" && (echo "Newest input (raw): $line" >> $LOGFILE)
	# if [[ -z "${init_row+x}" ]]; then
	# 	declare -r -i init_row=$(cursor_pos -r)
	# fi
	if [ -z "$line" ]; then
		if kill -0 $sub_pid > /dev/null 2>&1; then
			line=''
		else
			is_active="false"
		fi
	fi
	if eval $is_active && [ -n "$line" ]; then
		t_prior="$cumulative"
		cumulative+="$line"
		if ((start_int != 0)); then
			if eval "$extglob_off"; then shopt -s extglob; fi
			if eval "$patsub_replacement_off"; then shopt -s patsub_replacement; fi
			results_string="${cumulative:start_int}"
			eval "$DO_LOG" && (echo "$results_string" >> $LOGFILE)
			# if eval $ONE_CHAR_INPUT; then
				if [[ "$results_string" =~ $STATUS_LINE_PATTERN ]]; then
					modify_values "$line"
				elif [[ "${results_string:0:-1}" =~ $STATUS_LINE_PATTERN ]] && [ "${results_string: -1:1}" != $'\n' ]; then
					modify_values "${BASH_REMATCH[2]}" '-'
				fi
			# TODO: Finish status line parsing for multi-char input
			# else
			# 	if [[ "$results_string" =~ $STATUS_SEG_PATTERN ]]; then
			# 		modify_values "$line"
			# 	elif [[ "${results_string:0:-1}" =~ $STATUS_SEG_PATTERN ]] && [ "${results_string: -1:1}" != $'\n' ]; then
			# 		modify_values "${BASH_REMATCH[2]}" '-'
			# 	fi
			# fi
			if eval "$extglob_off"; then shopt -u extglob; fi
			if eval "$patsub_replacement_off"; then shopt -u patsub_replacement; fi
			status_text="$(gen_status_text)"
			eval "$DO_LOG" && (echo "$status_text" >> $LOGFILE)
		elif [[ $cumulative =~ $START_PATTERN ]]; then
			if eval $ONE_CHAR_INPUT; then
				start_int=${#cumulative}
			else
				start_int=${#BASH_REMATCH[1]}
			fi
			declare -i -r start_int
		fi
		display_text "$status_text" "$cumulative" "$line" "$t_prior"
	fi
done
tput rc
# tput rmcup
tput cnorm ed
echo $'\nSuccessfully completed!'
output="Iterations: $c_iterations
start_int: $start_int
Cumulative length: ${#cumulative}
Cumulative output:
$cumulative"
echo "$output"
eval "$DO_LOG" && (echo "$output" >> $LOGFILE)
exit