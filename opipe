#!/usr/bin/env bash

# https://www.kylheku.com/cgit/basta/tree/basta.sh?id=7fbdc5a088c37bd24da5954474a189cd4c890dce
# https://www.kylheku.com/cgit/basta/about/

readonly LOGFILE='/home/jmor/reposLocal/custom-shell-scripts/log.txt'
echo -n $'\n' >> $LOGFILE
date +'%T %D' >> $LOGFILE
# #region Signals
# https://man7.org/linux/man-pages/man7/signal.7.html
# readonly SIGHUP=1
# readonly SIGTRAP=5
# readonly SIGABRT=6
# readonly SIGKILL=9
# readonly SIGSTKFLT=16
# readonly SIGCHLD=17
# readonly SIGCONT=18
# readonly SIGSTOP=19
# readonly SIGTSTP=20
# readonly SIGTTIN=21
# readonly SIGTTOU=22
# readonly SIGPROF=27
# readonly SIGWINCH=28
readonly SIGINT=2
readonly SIGQUIT=3
readonly SIGTERM=15
# #endregion Signals
readonly STATUS_CHARACTERS='.FEWC'
readonly PATTERN="^([$STATUS_CHARACTERS]+)(([^[:print:][:blank:]][^.][[:print:][:blank:]]*)+[^[:print:][:blank:]]*)(.*)$"
readonly START_TEXT='

# Running:

$'
readonly ORIG_IFS=$IFS
current_count=0
display_text() {
	local -r text="$1"
	# tput smcup
	# init_pos=($(cursor_pos))
	# init_cols=$(tput cols)
	# init_lines=$(tput lines)
	tput sc
	tput cup $(($(tput lines) - 1)) 0 # $(($(tput cols) - ${#text} - 1))
	tput il1
	tput smso
	echo "$text"
	# tput rmso
	# tput rc
	# exit
	# tput rmcup
}
cumulative=""
line=""
exec 3< <("$@")
declare -i -r sub_pid=$!
out_pipe() {
	read -s -r -N 1 -u 3 line
}
is_active="true"
is_killing="false"
do_stop() {
	# shellcheck disable=SC2317
	if eval "$is_killing"; then
		kill -n "$1" "$sub_pid"
	else
		is_killing='true'
	fi
	# shellcheck disable=SC2317
	exitcode=$(wait "$sub_pid")
	# shellcheck disable=SC2317
	declare -i -r exitcode
	# shellcheck disable=SC2317
	exec 3>&-
	# shellcheck disable=SC2317
	exit $exitcode
}
# shellcheck disable=SC2064
trap "do_stop $SIGINT" INT
# shellcheck disable=SC2064
trap "do_stop $SIGQUIT" QUIT
# shellcheck disable=SC2064
trap "do_stop $SIGTERM" TERM
# trap "do_stop $SIGKILL" KILL
declare -i start_int=0
declare -i c_complete=0
declare -i c_successful=0
declare -i c_failure=0
readonly patsub_replacement_off=$( if [[ $(shopt patsub_replacement) =~ on$ ]]; then echo 'false'; else echo 'true'; fi )
readonly extglob_off=$( if [[ $(shopt extglob) =~ on$ ]]; then echo 'false'; else echo 'true'; fi )
while eval $is_active; do
	((current_count+=1))
	out_pipe
	echo "Newest input (raw): $line" >> $LOGFILE
	test
	if [ -z "$line" ]; then
		if kill -0 $sub_pid > /dev/null 2>&1; then
			line=''
			echo "(empty)"
		else
			echo -e "\nDONE!"
			is_active="false"
		fi
	fi
	if eval $is_active; then
		echo -n "$line"
		cumulative+="$line"
	fi
	if (( start_int != 0 )); then
		if eval "$extglob_off"; then shopt -s extglob; fi
		if eval "$patsub_replacement_off"; then shopt -s patsub_replacement; fi
		results_string="${cumulative:start_int}"
		echo "$results_string" >> $LOGFILE
		# while [[ "$results_string" =~ $'\n' ]]; do
		while [[ "$results_string" =~ $PATTERN ]]; do
			# echo "TO" >> $LOGFILE
			# echo "${BASH_REMATCH[1]}${BASH_REMATCH[4]}" >> $LOGFILE
			(cat <<- _EOF_
			TO
			${BASH_REMATCH[1]}${BASH_REMATCH[4]}

			_EOF_
			) >> $LOGFILE
			results_string="${BASH_REMATCH[1]}${BASH_REMATCH[4]}"
		done
		# while [[ "$results_string" =~ ^(\.+)([[:print:][:blank:]]*)(([^[:print:][:blank:]][^.][[:print:][:blank:]]*)+[^[:print:][:blank:]]*)(.*)$ ]]; do results_string="${BASH_REMATCH[1]}${BASH_REMATCH[5]}";done
		# done
		if eval "$extglob_off"; then shopt -u extglob; fi
		if eval "$patsub_replacement_off"; then shopt -u patsub_replacement; fi
		c_complete=${#results_string}
		t_buffer=$(echo "$results_string" | sed -E "s/[^.]//g")
		c_successful=${#t_buffer}
		t_buffer=$(echo "$results_string" | sed -E "s/[^F]//g")
		c_failure=${#t_buffer}
		echo "Final: $results_string" >> $LOGFILE
		echo "Completed: $c_complete, Successful: $c_successful, Failures: $c_failure" >> $LOGFILE
		# display_text "Completed: $c_complete"
		# tput rmso
		# tput rc
	elif [[ $cumulative =~ $START_TEXT ]]; then
		start_int=${#cumulative}
		declare -i -r start_int
	fi
done
echo "Successfully completed!"
echo "Iterations: $current_count
start_int: $start_int
Cumulative length: ${#cumulative}
Cumulative output:
$cumulative"
exit
# results_string='..............
# 1111111
# 22222222
# ....
# 3333333
# ..........
# Finished in 0.517201s, 46.4037 runs/s, 187.5481 assertions/s.
# 24 runs, 97 assertions, 0 failures, 0 errors, 0 skips
# '	[^[:print:][:blank:]]
# ^(\.+)([[:print:][:blank:]]*)([^[:print:][:blank:]][^.][[:print:][:blank:]]*)+
# ^(\.+)([[:print:][:blank:]]*)(([^[:print:][:blank:]][^.][[:print:][:blank:]]*)+[^[:print:][:blank:]]*)(.*)$