#!/usr/bin/env bash

##region########################################### GET PATH, DIR, & NAME ###########################################
readonly MY_PATH=$(realpath "$0")
MY_DIR=''
MY_NAME=''
if [[ "$MY_PATH" =~ ^(.*)/([^/]+)$ ]]; then
	readonly MY_DIR="${BASH_REMATCH[1]}" MY_NAME="${BASH_REMATCH[2]}"
else
	readonly MY_DIR="$HOME" MY_NAME="$0"
	echo "$MY_NAME: Failed to get dir" 1>&2
	exit 1
fi
##endregion######################################## GET PATH, DIR, & NAME ###########################################
##region########################################### SHOW HELP & VERSION ###########################################
show_help() {
	# -c, --coarseness COARSENESS: precision. Defaults to $DEFAULT_COARSENESS.
	cat << __EOF__
A typing test.

Usage:	$0 [VALID_CHARACTERS]
	or:	$0 --help
	or:	$0 --version

Options:
	-h, --help: Shows this help text.
	-v, --version: Shows version info.
__EOF__
}
show_version() {
	cat << __EOF__
$0 1.0.0

Copyright (C) 2025 Justin Morris
__EOF__
}
##endregion######################################## SHOW HELP & VERSION ###########################################
readonly LOGFILE="$MY_DIR/$MY_NAME.log.txt"
readonly WORDS_FILE="$MY_DIR/words.txt"
# readonly -a DEFAULT_CHARACTER_LIST=(
# 	asdfghjkl;wertyuio
# 	aeiou
# 	tyur
# )asdfghjkl;wertyuioaeioutyurtyurtyurtyur
readonly FG_GREEN="$(tput setaf 2)"
readonly FG_RED="$(tput setaf 1)"
readonly FG_WHITE="$(tput setaf 7)"
readonly FG_YELLOW="$(tput setaf 3)"
readonly BG_YELLOW="$(tput setab 3)"
readonly BG_BLACK="$(tput setab 0)"
readonly BACK_ONE="$(tput cub1)"
##region########################################### PARAMETERS ###########################################
declare -i max_dict_size=200
declare -i max_word_length=7
declare -i rows=3
declare -i columns=$(tput cols)
declare characters=' '
declare -a words=()
declare f_genWords='true'
declare -n opt1=characters opt2=testPath opt3=characters
while [[ -n "${1+x}" ]]; do
	case "$1" in
		(-h | --help)
			show_help
			exit
			;;
		(-v | --version)
			show_version
			exit
			;;
		# (-c | --coarseness)
		# 	shift
		# 	coarseInput="$1"
		# 	shift
		# 	;;
		(*)
			# if [[ -n "${opt1+x}" ]]; then
			# 	if [[ -n "${opt2+x}" ]]; then
			# 		if [[ -n "${opt3+x}" ]]; then
			# 			exit 1
			# 		else
						opt3+="$1"
			# 		fi
			# 	else
			# 		opt2="$1"
			# 	fi
			# else
			# 	opt1="$1"
			# fi
			shift
			;;
	esac
done
if ! eval "$f_genWords"; then
	mapfile -t words < <(grep --max-count=$max_dict_size -E --text -e "^[$characters]{1,$max_word_length}$" "$WORDS_FILE")
fi
##endregion######################################## PARAMETERS ###########################################
declare -a newTestLines=()
declare -a testLines=()
##region########################################### GENERATE TEST SEQUENCE ###########################################
# Dependent on:
# * newTestLines
function gen_test_sequence() {
	RANDOM=$$
	declare -g newTestLines=()
	local l_current_word=''
	# local -i l_iter=0
	# local -r matcherStart='(^| )'
	# local -r matcherEnd='( |$)'
	for ((j = 0; j < rows; j++)); do
		for ((i = 0; i < columns; i++)); do
			# ((l_iter++))
			if ((${#words[@]} > 0)); then
				# local badIndices=''
				local -a badIndices=()
				while true; do
					((t_ind=-1, loop = 0))
					# while ((t_ind < 0)) || [[ "$badIndices" =~ $matcherStart$t_ind$matcherEnd ]]; do
					while ((t_ind < 0)) || array_includes "$t_ind" "${badIndices[@]}"; do
						((loop++, t_ind = RANDOM % ${#words[@]}))
						if ((loop >= 100)); then break; fi
					done
					l_current_word="${words[$t_ind]}"
					local -i newLength=0
					((newLength = ${#newTestLines[j]} + ${#l_current_word}))
					# If it overflows the line...
					if ((newLength > columns)); then
						# ...and there's another line...
						if ((j + 1 < rows)); then
							# TODO: visual but not typed dash
							((newLength %= columns - 1, l_wordSlice=${#l_current_word} - newLength))
							newTestLines[j]+="${l_current_word:0:$l_wordSlice}-"
							((j++))
							newTestLines[j]+="${l_current_word: -$newLength} "
							((i=newLength))
							break
						# ...and there's not another line...
						else
							# ...and we've tried too many options...
							if ((loop >= 100)); then
								# TODO: Graceful early exit
								break 2
							# ...try another word
							else
								# badIndices+=" $t_ind"
								badIndices+=("$t_ind")
								continue
							fi
						fi
					# If it perfectly fills the line
					elif ((newLength == columns)); then
						newTestLines[j]+="$l_current_word"
						# Start w/ a space...
						if ((j + 1 < rows)); then
							((j++, i = 0))
							newTestLines[j]+=' '
							break
						# ...or we're done
						else
							break 3
						fi
					else
						newTestLines[j]+="$l_current_word"
						break
					fi
				done
				continue
			fi
			if ((${#l_current_word} >= max_word_length)); then
				l_current_word=''
				newTestLines[j]+=' '
			else
				((t_ind = RANDOM % ${#characters}))
				if [ "${characters:$t_ind:1}" = ' ' ]; then
					if [ "${l_current_word: -1}" != ' ' ] && (("${#l_current_word}" > 0)); then
						l_current_word=''
						newTestLines[j]+=' '
					else
						((i--))
						# ((l_iter--))
					fi
				else
					l_current_word+="${characters:$t_ind:1}"
					newTestLines[j]+="${l_current_word: -1}"
				fi
			fi
		done
	done
	# echo $l_iter $i $j
}
##endregion######################################## GENERATE TEST SEQUENCE ###########################################

gen_test_sequence
for item in "${newTestLines[@]}"; do
	testLines+=("$item")
done
doExit() { tput rmcup; exit; }
tput smcup; tput clear; trap 'tput rmcup' EXIT; trap 'doExit' INT
toWrite=''
for ((i = 0; i < rows; i++)); do
	toWrite+="${testLines[$i]}"
	toWrite+=$'\n\n'
done
echo -n -E "$toWrite"
tput cup 1 0
shopt -s globasciiranges extglob
declare -a inputs=('')
declare -a inputColors=('')
declare -A inputColorsBg=()
declare -i currRow=0
##region########################################### SETUP INPUT STREAM ###########################################
declare inputStreamName="$(mktemp --dry-run "$HOME/Desktop/j_type_inputStream_XXXX")"
if ! [[ "$inputStreamName" =~ ^$HOME/Desktop/j_type_inputStream_ ]]; then echo "Cannot safely rm -f $inputStreamName" 2>&1; exit 1; fi
mkfifo "$inputStreamName"
exec 3<>"$inputStreamName"; trap 'exec 3>&- 3<&-' EXIT
rm -f "$inputStreamName"
unset inputStreamName
exec 3<&0
##endregion######################################## SETUP INPUT STREAM ###########################################
# declare -r ORIG_IFS="$IFS"; IFS=$'\n'
declare -i currCol=0
stty -echo; trap 'stty echo' EXIT
##region########################################### ARRAY GETTERS/SETTERS ###########################################
_getXY() {
	local -i lRow=
	local -i lCol=
	if [[ "$1" =~ ^([[:digit:]])+\:([[:digit:]])+$ ]]; then
		local -ir lRow="${BASH_REMATCH[1]}"
		local -ir lCol="${BASH_REMATCH[2]}"
	else
		if [ -n "$1" ]; then
			local -ir lRow="$1"
		else
			local -ir lRow="$currRow"
		fi
		if [ -n "$2" ]; then
			local -ir lCol="$2"
		else
			local -ir lCol="${#inputs[$lRow]}"
			# echo "${inputs[$lRow]}" 1>&2
			# echo "lRow: ${lRow}" 1>&2
			# echo "inputs: ${inputs[*]}" 1>&2
			# lCol="${inputs[$lRow]}"
			# echo "lCol: ${lCol}" 1>&2
			# # if ! inputs[lRow]="${inputs[$lRow]}"; then
			# # 	local call i=0
			# # 	while call=caller $i; do
			# # 		((i++))
			# # 		echo $'\t'"$call" 1>&2
			# # 	done
			# # else
			# # fi
			# local -ir lCol
		fi
	fi
	echo $lRow $lCol
}
_getXYPrior() {
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); shift 2
	((lRow = lCol >= columns && lRow > 0 ? lRow - 1 : lRow))
	((lCol = lCol >= columns ? 0 : lCol - 1))
	echo $lRow $lCol
}
_getXYBeforePrior() {
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXYPrior "$@"); shift 2
	((lRow = lCol >= columns && lRow > 0 ? lRow - 1 : lRow))
	((lCol = lCol >= columns ? 0 : lCol - 1))
	echo $lRow $lCol
}
getCoord() {
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); local -ir lRow lCol
	echo -n "$lRow:$lCol"
	# echo -n "$currRow:${#inputs[$currRow]}"
}
getForPrior() {
	local lCommand="$1"; shift
	# if [ "${lCommand:0:3}" = 'set' ];
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXYPrior "$@"); shift 2
	$lCommand $lRow $lCol
}
setForPrior() {
	local lCommand="$1"; shift
	local lValue="$1"; shift
	# if [ "${lCommand:0:3}" = 'set' ];
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXYPrior "$@"); shift 2
	$lCommand "$lValue" $lRow $lCol
}
getForBeforePrior() {
	local lCommand="$1"; shift
	# if [ "${lCommand:0:3}" = 'set' ];
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXYBeforePrior "$@"); shift 2
	$lCommand $lRow $lCol
}
setForBeforePrior() {
	local lCommand="$1"; shift
	local lValue="$1"; shift
	# if [ "${lCommand:0:3}" = 'set' ];
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXYBeforePrior "$@"); shift 2
	$lCommand "$lValue" $lRow $lCol
}
getInput() {
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); local -ir lRow lCol
	local t="${inputs[$lRow]}"; echo -n "${t: $lCol:1}"
}
getInputColor() {
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); local -ir lRow lCol
	local t="${inputColors[$lRow]}"; echo -n "${t: $lCol:1}"
}
getInputColorBg() {
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); local -ir lRow lCol
	local t="$(getCoord $lRow $lCol)"; echo -n "${inputColorsBg[$t]}"
}
setInput() {
	local val="$1"; shift
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); local -ir lRow lCol; shift 2
	inputs[lRow]="${inputs[$lRow]:0:$lCol}${val}${inputs[$lRow]:$((lCol + 1))}"
}
setInputColor() {
	local val="$1"; shift
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); local -ir lRow lCol; shift 2
	inputColors[lRow]="${inputColors[$lRow]:0:$lCol}${val}${inputColors[$lRow]:$((lCol + 1))}"
}
setInputColorBg() {
	local val="$1"; shift
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); local -ir lRow lCol; shift 2
	local t="$(getCoord $lRow $lCol)"; inputColorsBg[$t]="$val"
}
##endregion######################################## ARRAY GETTERS/SETTERS ###########################################
_update() {
	local cache=''
	while ((${#cache} > 0)) || read -rsN 1 -u 3 -t .5 inputChar; do
		if ((${#cache} > 0)); then
			inputChar="${cache:0:1}"
			cache="${cache:1}"
		fi
		local -i currCol=${#inputs[$currRow]}
		local currChar="${testLines[$currRow]:$currCol:1}"
		local priorInputChar="${inputs[$currRow]: -2:1}"
		local preDisplay=''
		local postDisplay="$FG_WHITE"
		if [ -n "$(getInputColorBg)" ]; then
			preDisplay+="$(tput setab "$(getInputColorBg)")"
			postDisplay+="$BG_BLACK"
		fi
		doBackspace() {
			local l_coord="$(getForPrior getCoord)"
			if [ "$(getForPrior getInputColor)" = 1 ]; then
				inputColorsBg[$l_coord]=3
			fi
			if [ -n "${inputColorsBg[$l_coord]}" ]; then
				echo -n "$(tput setab "${inputColorsBg[$l_coord]}")"
			fi
			unset -v l_coord
			if [ -n "$(getForPrior getInputColor)" ]; then
				echo -n "$(tput setaf "$(getForPrior getInputColor)")"
			fi
			# unset "inputColors[$((currCol - 1))]"
			setForPrior setInputColor ''
			local l_display=$'\b'"${1:-$priorInputChar}"$'\b'"$BG_BLACK$FG_WHITE"
			echo -n "$l_display"
			unset -v l_display
			# Update logical inputs
			if ((currCol == 0 && currRow > 0)); then
				unset "inputs[$currRow]"
				((currRow--, currCol = columns - 1))
				return
			fi
			local l_t="${inputs[$currRow]}"
			inputs[currRow]="${l_t:0:-1}"
			priorInputChar="${l_t: -2:1}"
			unset -v l_t
		}
		if [ "$inputChar" = "$currChar" ]; then
			preDisplay+="$FG_GREEN"
			# inputColors[currCol]=2
			setInputColor 2
		elif [ "$inputChar" = "$(tput kbs)" ]; then # Backspace
			if ((currCol == 0 && currRow == 0)); then continue; fi # if [ -n "$priorInputChar" ]; then continue; fi
			doBackspace ' '
			continue
		elif [ "$inputChar" = $'\E' ]; then # ESCAPE SEQUENCE
			read -rsN 1 -u 3 escapeSequence
			# for ((i = 0; i < ${#escapeSequence}; i++)); do
			# 	if  [ "${escapeSequence:0:-$i}" = "$(tput khome)" ] || [ $'\E'"${escapeSequence:0:-$i}" = "$(tput khome)" ] || 
			# 		[ "${escapeSequence:0:-$i}" = $'\r' ] || [ $'\E'"${escapeSequence:0:-$i}" = $'\r' ] ||
			# 		[ "${escapeSequence:0:-$i}" = "[H" ]; then # Home
			# 		for ((; currCol > 0; currCol--)); do
			# 			doBackspace
			# 		done
			# 		continue 2
			# 	fi
			# done
			for ((i = ${#escapeSequence} - 1; i > 0; i--)); do
				cache="${escapeSequence:$i}"
				if  [ "${escapeSequence:0:-$i}" = "$(tput khome)" ] || [ $'\E'"${escapeSequence:0:-$i}" = "$(tput khome)" ] || 
					[ "${escapeSequence:0:-$i}" = $'\r' ] || [ $'\E'"${escapeSequence:0:-$i}" = $'\r' ] ||
					[ "${escapeSequence:0:-$i}" = "[H" ]; then # Home
					for ((; currCol > 0; currCol--)); do
						doBackspace
					done
					continue 2
				fi
			done
		else # Incorrect character
			preDisplay+="$FG_RED"
			# inputColors[currCol]=1
			setInputColor 1
			if [ "$inputChar" = ' ' ]; then
				preDisplay+="$(tput smso)"
				postDisplay="$(tput rmso)$postDisplay"
				inputChar="_"
			fi
		fi
		echo -n "$preDisplay$inputChar$postDisplay"
		inputs[currRow]+="$inputChar"
		if ((currCol + 1 == columns)); then
			tput cud 2
			echo -n $'\r'
			((currRow++))
		fi
	done
	tput cud $((rows * 2 - currRow * 2))
	local statusLine=$'\r'
	statusLine+="inputs: ${inputs[*]}$(tput el)"$' \b\n'
	statusLine+="inputColorsBg: $(declare -p inputColorsBg)$(tput el)"$' \b\n'
	statusLine+="inputColors: ${inputColors[*]}$(tput el)"$' \b\n'
	statusLine+="_getXY: $(_getXY)$(tput el)"$' \b\n'
	statusLine+="_getXYPrior: $(_getXYPrior)$(tput el)"$' \b\n'
	statusLine+="_getXYBeforePrior: $(_getXYBeforePrior)$(tput el)"$' \b\n'
	statusLine+="getCoord: $(getCoord)$(tput el)"$' \b\n'
	statusLine+="getForPrior getCoord: $(getForPrior getCoord)$(tput el)"$' \b\n'
	statusLine+="getForBeforePrior getCoord: $(getForBeforePrior getCoord)$(tput el)"$' \b\n'
	statusLine+="getInputColor: $(getInputColor)$(tput el)"$' \b\n'
	statusLine+="getForPrior 'getInputColor': $(getForPrior 'getInputColor')$(tput el)"$' \b\n'
	statusLine+="getForBeforePrior 'getInputColor': $(getForBeforePrior 'getInputColor')$(tput el)"$' \b\n'
	statusLine+="getInputColorBg: $(getInputColorBg)$(tput el)"$' \b\n'
	statusLine+="getForPrior 'getInputColorBg': $(getForPrior 'getInputColorBg')$(tput el)"$' \b\n'
	statusLine+="getForBeforePrior 'getInputColorBg': $(getForBeforePrior 'getInputColorBg')$(tput el)"$' \b\n'
	statusLine+="getInput: $(getInput)$(tput el)"$' \b\n'
	statusLine+="getForPrior 'getInput': $(getForPrior 'getInput')$(tput el)"$' \b\n'
	statusLine+="getForBeforePrior 'getInput': $(getForBeforePrior 'getInput')$(tput el)"$' \b\n'
	echo -n "$statusLine"
	# tput cuu "$(profile_text --edit_mode -r -- "$statusLine")"
	unset -v statusLine
	# tput cuu $((rows * 2 - currRow * 2 + 1))
	tput vpa $((currRow * 2 + 1))
	if ((${#inputs[$currRow]} > 0)); then
		tput cuf "${#inputs[$currRow]}"
	fi
}
while ((currRow < rows)); do _update; done
tput rmcup