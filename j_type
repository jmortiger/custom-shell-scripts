#!/usr/bin/env bash

##region########################################### GET PATH, DIR, & NAME ###########################################
readonly MY_PATH=$(realpath "$0")
MY_DIR=''
MY_NAME=''
if [[ "$MY_PATH" =~ ^(.*)/([^/]+)$ ]]; then
	readonly MY_DIR="${BASH_REMATCH[1]}" MY_NAME="${BASH_REMATCH[2]}"
else
	readonly MY_DIR="$HOME" MY_NAME="$0"
	echo "$MY_NAME: Failed to get dir" 1>&2
	exit 1
fi
##endregion######################################## GET PATH, DIR, & NAME ###########################################
##region########################################### SHOW HELP & VERSION ###########################################
show_help() {
	# or:	$0 [-c COARSENESS] [-d SEPARATOR] NUMERATOR DENOMINATOR
	# -c, --coarseness COARSENESS: precision. Defaults to $DEFAULT_COARSENESS.
	# -d, --decimal SEPARATOR: the fractional separator. Defaults to $DEFAULT_DECIMAL
	cat << __EOF__
A template I didn't replace.

Usage:	$0
	or:	$0 --help
	or:	$0 --version

Options:
	-h, --help: Shows this help text.
	-v, --version: Shows version info.
__EOF__
}
show_version() {
	cat << __EOF__
$0 1.0.0

Copyright (C) 2025 Justin Morris
__EOF__
}
##endregion######################################## SHOW HELP & VERSION ###########################################
readonly LOGFILE="$MY_DIR/$MY_NAME.log.txt"
# readonly -a DEFAULT_CHARACTER_LIST=(
# 	q w e r t y u i o p a
# )
declare -i max_word_length=7
declare -i rows=3
declare -i columns=$(tput cols)
declare characters=' '
declare -n opt1=characters opt2=testPath opt3=characters
while [[ -n "${1+x}" ]]; do
	case "$1" in
		(-h | --help)
			show_help
			exit
			;;
		(-v | --version)
			show_version
			exit
			;;
		# (-c | --coarseness)
		# 	shift
		# 	coarseInput="$1"
		# 	shift
		# 	;;
		# (-d | --decimal)
		# 	shift
		# 	separator="$1"
		# 	shift
		# 	;;
		(*)
			# if [[ -n "${opt1+x}" ]]; then
			# 	if [[ -n "${opt2+x}" ]]; then
			# 		if [[ -n "${opt3+x}" ]]; then
			# 			exit 1
			# 		else
						opt3+="$1"
			# 		fi
			# 	else
			# 		opt2="$1"
			# 	fi
			# else
			# 	opt1="$1"
			# fi
			shift
			;;
	esac
done
declare -a newTestLines=()
declare -a testLines=()
##region########################################### GENERATE TEST SEQUENCE ###########################################
function gen_test_sequence() {
	RANDOM=$$
	declare -g newTestLines=()
	local l_current_word=''
	# local -i l_iter=0
	for ((j = 0; j < rows; j++)); do
		for ((i = 0; i < columns; i++)); do
			# ((l_iter++))
			if ((${#l_current_word} >= max_word_length)); then
				l_current_word=''
				newTestLines[j]+=' '
			else
				((t_ind = RANDOM % ${#characters}))
				if [ "${characters:$t_ind:1}" = ' ' ]; then
					if [ "${l_current_word: -1}" != ' ' ] && (("${#l_current_word}" > 0)); then
						l_current_word=''
						newTestLines[j]+=' '
					else
						((i--))
						# ((l_iter--))
					fi
				else
					l_current_word+="${characters:$t_ind:1}"
					newTestLines[j]+="${l_current_word: -1}"
				fi
			fi
		done
	done
	# echo $l_iter $i $j
}
##endregion######################################## GENERATE TEST SEQUENCE ###########################################

gen_test_sequence
for item in "${newTestLines[@]}"; do
	# echo "$item"
	testLines+=("$item")
done
# echo "${testLines[*]}"
# echo "${newTestLines[*]}"
# exit
tput smcup
tput clear
# echo -n $'\n'

declare -a inputs=('')
declare -i currRow=0
get_currCol() {
	local temp="${inputs[$currRow]}"
	echo "${#temp}"
}
toWrite=''
for ((i = 0; i < rows; i++)); do
	toWrite+="${testLines[$i]}"
	toWrite+=$'\n\n'
	# echo -n $'\n'
done
echo -n -E "$toWrite"
tput cup 1 0
shopt -s globasciiranges extglob
while ((currRow < rows)); do
	# for ((i = 0; i < rows; i++)); do
	# 	echo "${testLines[$i]}"
	# 	echo -n $'\n'
	# done
	declare currCol=$(get_currCol)
	declare currLine="${testLines[$currRow]}"
	if read -s -r -N 1 newChar && ((${#newChar} == 1)) && [[ "$newChar" =~ ^[[:print:]]$ ]]; then
		inputs[currRow]+="${newChar}"
		if [ "$newChar" = "${currLine:$currCol:1}" ]; then
			tput setaf 2
		else
			tput setaf 1
			if [ "$newChar" = ' ' ]; then newChar='_'; fi
		fi
		echo -n "$newChar"
		tput setaf 7
		if ((${#inputs[$currRow]} == columns)); then
			((currRow++))
			tput cud 2
			echo -n $'\r'
		fi
	fi
	# for ((i = 0; i <= currRow; i++)); do
	# 	echo "${inputs[$i]}"
	# 	echo -n $'\n'
	# done
done
tput rmcup