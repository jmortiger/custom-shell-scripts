#!/usr/bin/env bash

##region########################################### GET PATH, DIR, & NAME ###########################################
readonly MY_PATH=$(realpath "$0")
MY_DIR=''
MY_NAME=''
if [[ "$MY_PATH" =~ ^(.*)/([^/]+)$ ]]; then
	readonly MY_DIR="${BASH_REMATCH[1]}" MY_NAME="${BASH_REMATCH[2]}"
else
	readonly MY_DIR="$HOME" MY_NAME="$0"
	echo "$MY_NAME: Failed to get dir" 1>&2
	exit 1
fi
##endregion######################################## GET PATH, DIR, & NAME ###########################################
##region########################################### SHOW HELP & VERSION ###########################################
show_help() {
	# or:	$0 [-c COARSENESS] [-d SEPARATOR] NUMERATOR DENOMINATOR
	# -c, --coarseness COARSENESS: precision. Defaults to $DEFAULT_COARSENESS.
	# -d, --decimal SEPARATOR: the fractional separator. Defaults to $DEFAULT_DECIMAL
	cat << __EOF__
A template I didn't replace.

Usage:	$0
	or:	$0 --help
	or:	$0 --version

Options:
	-h, --help: Shows this help text.
	-v, --version: Shows version info.
__EOF__
}
show_version() {
	cat << __EOF__
$0 1.0.0

Copyright (C) 2025 Justin Morris
__EOF__
}
##endregion######################################## SHOW HELP & VERSION ###########################################
readonly LOGFILE="$MY_DIR/$MY_NAME.log.txt"
readonly WORDS_FILE="$MY_DIR/words.txt"
# readonly -a DEFAULT_CHARACTER_LIST=(
# 	q w e r t y u i o p a
# )
declare -i max_dict_size=200
declare -i max_word_length=7
declare -i rows=3
declare -i columns=$(tput cols)
declare characters=' '
declare -a words=()
declare f_genWords='true'
declare -n opt1=characters opt2=testPath opt3=characters
while [[ -n "${1+x}" ]]; do
	case "$1" in
		(-h | --help)
			show_help
			exit
			;;
		(-v | --version)
			show_version
			exit
			;;
		# (-c | --coarseness)
		# 	shift
		# 	coarseInput="$1"
		# 	shift
		# 	;;
		# (-d | --decimal)
		# 	shift
		# 	separator="$1"
		# 	shift
		# 	;;
		(*)
			# if [[ -n "${opt1+x}" ]]; then
			# 	if [[ -n "${opt2+x}" ]]; then
			# 		if [[ -n "${opt3+x}" ]]; then
			# 			exit 1
			# 		else
						opt3+="$1"
			# 		fi
			# 	else
			# 		opt2="$1"
			# 	fi
			# else
			# 	opt1="$1"
			# fi
			shift
			;;
	esac
done
if ! eval "$f_genWords"; then
	mapfile -t words < <(grep -m $max_dict_size -E --text -e "^[$characters]{1,$max_word_length}$" "$WORDS_FILE")
fi
declare -a newTestLines=()
declare -a testLines=()
##region########################################### GENERATE TEST SEQUENCE ###########################################
function gen_test_sequence() {
	RANDOM=$$
	declare -g newTestLines=()
	local l_current_word=''
	# local -i l_iter=0
	# local -r matcherStart='(^| )'
	# local -r matcherEnd='( |$)'
	for ((j = 0; j < rows; j++)); do
		for ((i = 0; i < columns; i++)); do
			# ((l_iter++))
			if ((${#words[@]} > 0)); then
				# local badIndices=''
				local -a badIndices=()
				while true; do
					((t_ind=-1, loop = 0))
					# while ((t_ind < 0)) || [[ "$badIndices" =~ $matcherStart$t_ind$matcherEnd ]]; do
					while ((t_ind < 0)) || array_includes "$t_ind" "${badIndices[@]}"; do
						((loop++, t_ind = RANDOM % ${#words[@]}))
						if ((loop >= 100)); then break; fi
					done
					l_current_word="${words[$t_ind]}"
					local -i newLength=0
					((newLength = ${#newTestLines[j]} + ${#l_current_word}))
					# If it overflows the line...
					if ((newLength > columns)); then
						# ...and there's another line...
						if ((j + 1 < rows)); then
							# TODO: visual but not typed dash
							((newLength %= columns - 1, l_wordSlice=${#l_current_word} - newLength))
							newTestLines[j]+="${l_current_word:0:$l_wordSlice}-"
							((j++))
							newTestLines[j]+="${l_current_word: -$newLength} "
							((i=newLength))
							break
						# ...and there's not another line...
						else
							# ...and we've tried too many options...
							if ((loop >= 100)); then
								# TODO: Graceful early exit
								break 2
							# ...try another word
							else
								# badIndices+=" $t_ind"
								badIndices+=("$t_ind")
								continue
							fi
						fi
					# If it perfectly fills the line
					elif ((newLength == columns)); then
						newTestLines[j]+="$l_current_word"
						# Start w/ a space...
						if ((j + 1 < rows)); then
							((j++, i = 0))
							newTestLines[j]+=' '
							break
						# ...or we're done
						else
							break 3
						fi
					else
						newTestLines[j]+="$l_current_word"
						break
					fi
				done
				continue
			fi
			if ((${#l_current_word} >= max_word_length)); then
				l_current_word=''
				newTestLines[j]+=' '
			else
				((t_ind = RANDOM % ${#characters}))
				if [ "${characters:$t_ind:1}" = ' ' ]; then
					if [ "${l_current_word: -1}" != ' ' ] && (("${#l_current_word}" > 0)); then
						l_current_word=''
						newTestLines[j]+=' '
					else
						((i--))
						# ((l_iter--))
					fi
				else
					l_current_word+="${characters:$t_ind:1}"
					newTestLines[j]+="${l_current_word: -1}"
				fi
			fi
		done
	done
	# echo $l_iter $i $j
}
##endregion######################################## GENERATE TEST SEQUENCE ###########################################

gen_test_sequence
for item in "${newTestLines[@]}"; do
	# echo "$item"
	testLines+=("$item")
done
# echo "${testLines[*]}"
# echo "${newTestLines[*]}"
# exit
tput smcup
tput clear
# echo -n $'\n'

declare -a inputs=('')
declare -i currRow=0
get_currCol() {
	local temp="${inputs[$currRow]}"
	echo "${#temp}"
}
toWrite=''
for ((i = 0; i < rows; i++)); do
	toWrite+="${testLines[$i]}"
	toWrite+=$'\n\n'
	# echo -n $'\n'
done
echo -n -E "$toWrite"
tput cup 1 0
shopt -s globasciiranges extglob
# exec 3<&0
# exec <&3
declare -r ORIG_IFS="$IFS"
IFS=$'\n'
while ((currRow < rows)); do
	declare currCol=$(get_currCol)
	declare currLine="${testLines[$currRow]}"
	# if read -s -r -t .3 newChar && [[ "$newChar" =~ ^[[:print:]]$ ]]; then
	newChar=''
	read -s -r -n 1 -t .2 newChar
	# if read -s -r -t .2 newChar; then
		# while read -s -r -t 0; do read -s -r -N 1; newChar+="$REPLY"; done
		while ((0 < ${#newChar})); do
			if [[ "${newChar:0:1}" =~ ^[^[:print:]' ']$ ]]; then
				newChar="${newChar:1}"
				continue
			fi
			inputs[currRow]+="${newChar:0:1}"
			if [ "${newChar:0:1}" = "${currLine:$currCol:1}" ]; then
				tput setaf 2
			else
				tput setaf 1
				if [ "${newChar:0:1}" = ' ' ]; then newChar="_${newChar:1}"; fi
			fi
			echo -n "${newChar:0:1}"
			tput setaf 7
			if ((${#inputs[$currRow]} == columns)); then
				((currRow++))
				tput cud 2
				echo -n $'\r'
			fi
			newChar="${newChar:1}"
		done
	# fi
	# for ((i = 0; i <= currRow; i++)); do
	# 	echo "${inputs[$i]}"
	# 	echo -n $'\n'
	# done
done
tput rmcup