#!/usr/bin/env bash

##region########################################### GET PATH, DIR, & NAME ###########################################
readonly MY_PATH=$(realpath "$0")
MY_DIR=''
MY_NAME=''
if [[ "$MY_PATH" =~ ^(.*)/([^/]+)$ ]]; then
	readonly MY_DIR="${BASH_REMATCH[1]}" MY_NAME="${BASH_REMATCH[2]}"
else
	readonly MY_DIR="$HOME" MY_NAME="$0"
	echo "$MY_NAME: Failed to get dir" 1>&2
	exit 1
fi
##endregion######################################## GET PATH, DIR, & NAME ###########################################
##region########################################### SHOW HELP & VERSION ###########################################
show_help() {
	# -c, --coarseness COARSENESS: precision. Defaults to $DEFAULT_COARSENESS.
	cat << __EOF__
A typing test.

Usage:	$0 [VALID_CHARACTERS]
	or:	$0 --help
	or:	$0 --version

Options:
	-h, --help: Shows this help text.
	-v, --version: Shows version info.
__EOF__
}
show_version() {
	cat << __EOF__
$0 1.0.0

Copyright (C) 2025 Justin Morris
__EOF__
}
##endregion######################################## SHOW HELP & VERSION ###########################################
readonly LOGFILE="$MY_DIR/$MY_NAME.log.txt"
readonly WORDS_FILE="$MY_DIR/words.txt"
# readonly -a DEFAULT_CHARACTER_LIST=(
# 	asdfghjkl;wertyuio
# 	aeiou
# 	tyur
# )asdfghjkl;wertyuioaeioutyurtyurtyurtyur
declare -A CTR_SEQ=; eval "$(misc_util CTR_SEQ)"
declare -A TPUT_COLOR=; eval "$(misc_util TPUT_COLOR)"
declare -i MAX_READ_INT=; eval "$(misc_util MAX_READ_INT)"
declare RESET_COLOR_BACKGROUND=; eval "$(misc_util RESET_COLOR_BACKGROUND)"
declare RESET_COLOR_FOREGROUND=; eval "$(misc_util RESET_COLOR_FOREGROUND)"
##region########################################### PARAMETERS ###########################################
# The time in seconds after which an update will be forced.
declare -ir FORCE_REFRESH_INTERVAL=5
# The time in seconds after which an update will be attempted.
declare -ir REFRESH_INTERVAL=1
declare -i maxDictSize=100000
declare -i maxWordLength=7
declare -i rows=3
declare -i columns=$(tput cols)
declare characters=' '
declare -a words=()
# Dynamically generate nonsense words?
declare f_genWords='true'
declare f_properPunctuation='true'
declare -n opt1=characters opt2=testPath opt3=characters
while [[ -n "${1+x}" ]]; do
	case "$1" in
		(-h | --help) show_help; exit;;
		(-v | --version) show_version; exit;;
		# (-c | --coarseness)
		# 	shift
		# 	coarseInput="$1"
		# 	shift
		# 	;;
		(*)
			# if [[ -n "${opt1+x}" ]]; then
			# 	if [[ -n "${opt2+x}" ]]; then
			# 		if [[ -n "${opt3+x}" ]]; then
			# 			exit 1
			# 		else
						opt3+="$1"
			# 		fi
			# 	else
			# 		opt2="$1"
			# 	fi
			# else
			# 	opt1="$1"
			# fi
			shift
			;;
	esac
done
if ! eval "$f_genWords"; then
	# match only the words that are short enough & only have valid characters
	mapfile -t words < <(grep --max-count=$maxDictSize -E --text -e "^[$characters]{1,$maxWordLength}$" "$WORDS_FILE")
fi
declare -r ORIG_IFS="$IFS"
# 1: max length
# 2: valid chars
getRandomWord() {
	local -a validWords
	if [ -n "${words[*]}" ]; then
		IFS=$'\n'
		mapfile -t validWords < <(echo -n "${words[*]}" | grep --max-count=$maxDictSize -E --text -e "^[$characters]{1,$1}$")
		IFS="$ORIG_IFS"
	else
		mapfile -t validWords < <(grep --max-count=$maxDictSize -E --text -e "^[${2:-$characters}]{1,${1:-$maxWordLength}}$" "$WORDS_FILE")
	fi
	local -i t_ind=$RANDOM%${#validWords[@]}
	echo -n "${validWords[$t_ind]}"
}
##endregion######################################## PARAMETERS ###########################################
declare -a newTestLines=()
declare -a testLines=()
##region########################################### GENERATE TEST SEQUENCE ###########################################
# Dependent on:
# * newTestLines
function genTestSequence() {
	RANDOM=$$
	declare -g newTestLines=()
	local l_current_word=''
	# local -ir rows=
	for ((j = 0; j < rows; j++)); do
		for ((i = 0; i < columns; i++)); do
			if ((${#l_current_word} >= maxWordLength)); then
				l_current_word=''
				# TODO: Add chance to add a punctuation or space if following grammar rules
				newTestLines[j]+=' '
				continue
			fi
			if ((${#words[@]} > 0)); then
				local -a badIndices=()
				while true; do
					((t_ind = RANDOM % ${#words[@]}, loop = 0))
					for ((t_ind = RANDOM % ${#words[@]}, loop = 0; loop < 100; loop++, t_ind = RANDOM % ${#words[@]})); do
						if ! array_includes "$t_ind" "${badIndices[@]}"; then
							break;
						fi
					done
					l_current_word="${words[$t_ind]}"
					local -i newLength=0
					((newLength = ${#newTestLines[j]} + ${#l_current_word}))
					# If it overflows the line...
					if ((newLength > columns)); then
						# ...and there's another line...
						if ((j + 1 < rows)); then
							# TODO: visual but not typed dash
							((newLength %= columns - 1, l_wordSlice=${#l_current_word} - newLength))
							newTestLines[j]+="${l_current_word:0:$l_wordSlice}-"
							((j++))
							newTestLines[j]+="${l_current_word: -$newLength} "
							l_current_word=
							((i = ${#newTestLines[j]} - 1))
							break
						# ...and there's not another line...
						else
							# ...and we've tried too many options...
							if ((loop >= 100)); then
								# TODO: Graceful early exit
								break 2
							# ...try another word
							else
								badIndices+=("$t_ind")
								continue
							fi
						fi
					# If it perfectly fills the line
					elif ((newLength == columns)); then
						newTestLines[j]+="$l_current_word"
						# If there's another line...
						if ((j + 1 < rows)); then
							# ...start it w/ a space
							((j++))
							newTestLines[j]+=' '
							((i = ${#newTestLines[j]} - 1))
							l_current_word=
							break
						else # ...or we're done
							break 3
						fi
					else # It fits, but doesn't fill, the line (disregarding the trailing space)
						newTestLines[j]+="$l_current_word "
						((i = ${#newTestLines[j]} - 1))
						l_current_word=
						break
					fi
				done
				continue
			fi
			((t_ind = RANDOM % ${#characters}))
			local tChar="${characters:$t_ind:1}"
			if [ "$tChar" = ' ' ]; then
				# It doesn't end in space & isn't empty
				if [ "${newTestLines[$j]: -1}" != ' ' ] && (("${#l_current_word}" > 0)); then
					l_current_word=''
					newTestLines[j]+="$tChar"
				else # Try again
					((i--))
				fi
			elif eval "$f_properPunctuation"; then
				if [[ "$tChar" =~ [\;\,\.\:\!] ]]; then
					# If there's space for the char + a space, it's preceded by a letter/number, & the word isn't empty
					if  ((${#newTestLines[$j]} + 2 < columns)) && 
						[[ "${newTestLines[$j]: -1}" =~ [[:alnum:]] ]] && 
						(("${#l_current_word}" > 0)); then
						l_current_word=''
						newTestLines[j]+="$tChar "
						((i++))
					else # Try again
						((i--))
					fi
				else
					l_current_word+="$tChar"
					newTestLines[j]+="$tChar"
				fi
			else
				l_current_word+="$tChar"
				newTestLines[j]+="$tChar"
			fi
			unset tChar
		done
	done
}
# function _testGenerator() {
# 	function _test_punctuation() {
# 		genTestSequence
# 	}
# }
##endregion######################################## GENERATE TEST SEQUENCE ###########################################

genTestSequence
# unset words
for item in "${newTestLines[@]}"; do testLines+=("$item"); done
doExit() { tput rmcup; exit; }
tput smcup; tput clear; trap 'tput rmcup' EXIT; trap 'doExit' INT
echo -nE "$(array_join $'\n\n' "${testLines[@]}")"
tput cup 1 0
shopt -s globasciiranges extglob
declare -a inputs=('')
declare -a inputColors=('')
declare -A inputColorsBg=()
declare -i currRow=0
##region########################################### SETUP INPUT STREAM ###########################################
declare inputStreamName="$(mktemp --dry-run "$HOME/Desktop/j_type_inputStream_XXXX")"
if ! [[ "$inputStreamName" =~ ^$HOME/Desktop/j_type_inputStream_ ]]; then echo "Cannot safely rm -f $inputStreamName" 2>&1; exit 1; fi
mkfifo "$inputStreamName"
exec 3<>"$inputStreamName"; trap 'exec 3>&- 3<&-' EXIT
rm -f "$inputStreamName"
unset inputStreamName
exec 3<&0
##endregion######################################## SETUP INPUT STREAM ###########################################
# declare -r ORIG_IFS="$IFS"; IFS=$'\n'
stty -echo; trap 'stty echo' EXIT
##region########################################### ARRAY GETTERS/SETTERS ###########################################
_getXY() {
	local -i lRow=
	local -i lCol=
	if [[ "$1" =~ ^([[:digit:]])+\:([[:digit:]])+$ ]]; then
		local -ir lRow="${BASH_REMATCH[1]}"
		local -ir lCol="${BASH_REMATCH[2]}"
	else
		if [ -n "$1" ]; then
			local -ir lRow="$1"
		else
			local -ir lRow="$currRow"
		fi
		if [ -n "$2" ]; then
			local -ir lCol="$2"
		else
			local -ir lCol="${#inputs[$lRow]}"
		fi
	fi
	echo $lRow $lCol
}
_getXYNext() {
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@")
	# if ((lCol >= columns && lRow < rows)); then
	if ((lCol >= columns)); then
		((lCol = 0, lRow++))
	else
		((lCol++))
	fi
	echo $lRow $lCol
}
_getXYAfterNext() { read -sr lRow lCol < <(_getXYNext "$@"); _getXYNext "$lRow" "$lCol"; }
_getXYPrior() {
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@")
	if ((lCol <= 0 && lRow > 0)); then
		((lCol = columns - 1, lRow--))
	else
		((lCol--))
	fi
	echo $lRow $lCol
}
_getXYBeforePrior() { read -sr lRow lCol < <(_getXYPrior "$@"); _getXYPrior "$lRow" "$lCol"; }
getCoord() {
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); local -ir lRow lCol
	echo -n "$lRow:$lCol"
	# echo -n "$currRow:${#inputs[$currRow]}"
}
getForPrior() {
	local lCommand="$1"; shift
	# if [ "${lCommand:0:3}" = 'set' ];
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXYPrior "$@"); shift 2
	$lCommand $lRow $lCol
}
setForPrior() {
	local lCommand="$1"; shift
	local lValue="$1"; shift
	# if [ "${lCommand:0:3}" = 'set' ];
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXYPrior "$@"); shift 2
	$lCommand "$lValue" $lRow $lCol
}
getForBeforePrior() {
	local lCommand="$1"; shift
	# if [ "${lCommand:0:3}" = 'set' ];
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXYBeforePrior "$@"); shift 2
	$lCommand $lRow $lCol
}
setForBeforePrior() {
	local lCommand="$1"; shift
	local lValue="$1"; shift
	# if [ "${lCommand:0:3}" = 'set' ];
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXYBeforePrior "$@"); shift 2
	$lCommand "$lValue" $lRow $lCol
}
# shellcheck disable=SC2120
getTestChar() {
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); local -ir lRow lCol
	local t="${testLines[$lRow]}"; echo -n "${t: $lCol:1}"
}
# shellcheck disable=SC2120
getInput() {
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); local -ir lRow lCol
	local t="${inputs[$lRow]}"; echo -n "${t: $lCol:1}"
}
# shellcheck disable=SC2120
getInputColor() {
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); local -ir lRow lCol
	local t="${inputColors[$lRow]}"; echo -n "${t: $lCol:1}"
}
# shellcheck disable=SC2120
getInputColorBg() {
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); local -ir lRow lCol
	local t="$(getCoord $lRow $lCol)"; echo -n "${inputColorsBg[$t]}"
}
setInput() {
	local val="$1"; shift
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); local -ir lRow lCol; shift 2
	inputs[lRow]="${inputs[$lRow]:0:$lCol}${val}${inputs[$lRow]:$((lCol + 1))}"
}
setInputColor() {
	local val="$1"; shift
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); local -ir lRow lCol; shift 2
	inputColors[lRow]="${inputColors[$lRow]:0:$lCol}${val}${inputColors[$lRow]:$((lCol + 1))}"
}
setInputColorBg() {
	local val="$1"; shift
	local -i lRow=; local -i lCol=; read -sr lRow lCol < <(_getXY "$@"); local -ir lRow lCol; shift 2
	local t="$(getCoord $lRow $lCol)"; inputColorsBg[$t]="$val"
}
##endregion######################################## ARRAY GETTERS/SETTERS ###########################################
getCurrInputColNum()  { echo -n ${#inputs[$currRow]}; }
getInputColNum()  { if [ -z "$1" ]; then echo -n ${#inputs[$currRow]}; else echo -n ${#inputs[$1]}; fi; }
# setCurrInputColNum() { echo -n ${#inputs[$currRow]}; }
addToInput() {
	local -i linesAdded=0; local -i myCurrRow=$currRow; local -i myCurrCol=$(getCurrInputColNum)
	for ((i = 0; i < "${#1}"; i++, myCurrCol++)); do
		inputs[myCurrRow]+="${1:$i:1}"
		if ((myCurrCol + 1 == columns)); then
			((myCurrCol = -1))
			((myCurrRow++))
			((linesAdded++))
		elif ((myCurrCol + 1 > columns)); then
			echo "$myCurrCol > columns ($columns)"
			sleep 3
			exit 1 # TODO: THROW
		fi
	done
	return $linesAdded
}
dryAddToInput() {
	local -i linesAdded=0; local -i myCurrRow=$currRow; local -i myCurrCol=$(getCurrInputColNum)
	for ((i = 0; i < "${#1}"; i++, myCurrCol++)); do
		# inputs[myCurrRow]+="${1:$i:1}"
		if ((myCurrCol + 1 == columns)); then
			((myCurrCol = -1))
			((myCurrRow++))
			((linesAdded++))
		elif ((myCurrCol + 1 > columns)); then
			echo "$myCurrCol > columns ($columns)"
			sleep 3
			exit 1 # TODO: THROW
		fi
	done
	return $linesAdded
}
removeCharacterAt() {
	local -i myCurrRow=$1; local -i myCurrCol=$2; local -i precedingCol=$myCurrCol-1; local line="${inputs[$myCurrRow]}"
	((${#line} > 0)) && echo -n "${line:0:$precedingCol}${line:$myCurrCol}"
}
removeFromInput() {
	local -i linesRemoved=0; local -i myCurrRow=$currRow; local -i myCurrCol=$(getInputColNum $myCurrRow)
	for ((i = 0; i < "$1"; i++, myCurrCol--)); do
		if ((myCurrCol == 0 && myCurrRow > 0)); then
			((myCurrRow--))
			((myCurrCol = $(getInputColNum $myCurrRow)))
			((linesRemoved++))
		elif ((myCurrCol < 0)); then
			echo "$myCurrCol < 0"
			sleep 3
			exit 1 # TODO: THROW
		fi
		inputs[myCurrRow]="${inputs[$myCurrRow]:0:$((myCurrCol - 1))}${inputs[$myCurrRow]:$myCurrCol}"
		# inputs[myCurrRow]="$(removeCharacterAt $myCurrRow $myCurrCol)"
	done
	return $linesRemoved
}
# setCurrInputColChar() { echo -n "${inputs[$currRow]: -1}"; }
declare -i lastUpdate=$(date -u +'%-s')
badInputs=''
_update() {
	local cache=''
	while ((${#cache} > 0)) || read -rsN 1 -u 3 -t .5 inputChar; do
		if ((${#cache} > 0)); then
			inputChar="${cache:0:1}"
			cache="${cache:1}"
		fi
		local -i currTime=$(date -u +'%-s')
		local preDisplay=''
		local postDisplay="$RESET_COLOR_FOREGROUND"
		# Assumes
			# * Color handled in `preDisplay` & `postDisplay`
			# * `inputChar` holds what to add to `inputs[currRow]`
			# * `inputChar` holds 1 character
		_addToOutput() {
			echo -n "$preDisplay$inputChar$postDisplay"
			local -i linesAdded=0 i=0
			addToInput "$inputChar"
			linesAdded=$?
			for ((i = 0; i < linesAdded; i++)); do
				tput cud 2
				echo -n $'\r'
				((currRow++))
			done
		}
		# Assumes
			# * Color handled in `preDisplay` & `postDisplay`
			# * `inputChar` holds what to add to `inputs[currRow]`
			# * `inputChar` holds 1 character
		visualAddToOutput() {
			echo -n "$preDisplay$inputChar$postDisplay$(tput cub1)"
			# local -i linesAdded=0 i=0
			# dryAddToInput "$inputChar"
			# linesAdded=$?
			# for ((i = 0; i < linesAdded; i++)); do
			# 	tput cud 2
			# 	echo -n $'\r'
			# 	((currRow++))
			# done
		}
		# shellcheck disable=SC2119
		if [ -n "$(getInputColorBg)" ]; then
			preDisplay+="$(tput setab "$(getInputColorBg)")"
			postDisplay+="$RESET_COLOR_BACKGROUND"
		fi
		visualScrollLeft() {
			local l_coord="$(getForPrior getCoord)"
			if [ "$(getForPrior getInputColor)" = 1 ]; then
				inputColorsBg[$l_coord]=3
			fi
			if [ -n "${inputColorsBg[$l_coord]}" ]; then
				echo -n "$(tput setab "${inputColorsBg[$l_coord]}")"
			fi
			unset l_coord
			if [ -n "$(getForPrior getInputColor)" ]; then
				echo -n "$(tput setaf "$(getForPrior getInputColor)")"
			fi
			setForPrior setInputColor ''
			if (($(getCurrInputColNum) == 0 && currRow > 0)); then
				tput cuu 2
				tput hpa $((columns - 1))
				echo -n "${1:-$(getForPrior getInput)}"$'\b'"$RESET_COLOR_BACKGROUND$RESET_COLOR_FOREGROUND"
			else
				echo -n $'\b'"${1:-$(getForPrior getInput)}"$'\b'"$RESET_COLOR_BACKGROUND$RESET_COLOR_FOREGROUND"
			fi
		}
		# TODO: Finish
		logicalScrollLeft() {
			if (($(getCurrInputColNum) == 0 && currRow <= 0)); then return; fi
			visualScrollLeft
			# local -i linesRemoved=0
			# removeFromInput 1
			# linesRemoved=$?
			# ((currRow-=linesRemoved))
		}
		doBackspace() {
			if (($(getCurrInputColNum) == 0 && currRow <= 0)); then return; fi
			visualScrollLeft "$1"
			local -i linesRemoved=0
			removeFromInput 1
			linesRemoved=$?
			((currRow-=linesRemoved))
		}
		invalidCharacter() {
			preDisplay+="${TPUT_COLOR[RED]}"
			setInputColor 1
			preDisplay+="$(tput smso)"
			postDisplay="$(tput rmso)$postDisplay"
			badInputs+="$inputChar"
			inputChar="?"
			_addToOutput
		}
		if [ "$inputChar" = "$(getTestChar)" ]; then
			preDisplay+="${TPUT_COLOR[GREEN]}"
			setInputColor 2
			_addToOutput
		elif [ "$inputChar" = "$(tput kbs)" ]; then # Backspace
			# If there's nothing to backspace, skip
			if (($(getCurrInputColNum) <= 0 && currRow <= 0)); then continue; fi
			doBackspace ' '
			# continue
		elif [ "$inputChar" = $'\E' ]; then # ESCAPE SEQUENCE
			local escapeSequence
			if ((${#cache} > 0)); then
				local escapeSequence="$cache"
				cache=''
			else
				read -rsN $MAX_READ_INT -u 3 -t .01 escapeSequence
			fi
			# TODO: If empty i.e. esc was pressed
			# From the end of cache, search for the longest matching escape sequence.
			for ((iEsc = ${#escapeSequence}; iEsc > 0; iEsc--)); do
				cache="${escapeSequence:$iEsc}$cache"
				escapeSequence="${escapeSequence:0:$iEsc}"
				if  [ "${CTR_SEQ[home]}" = $'\e'"$escapeSequence" ]; then
					# TODO: allow non-destructive scroll-back
					##region################################# Actual Output #################################
					# local -i currCol
					# for ((currCol=$(getCurrInputColNum); currCol > 0; currCol--)); do
					# 	logicalScrollLeft
					# done; unset currCol
					##endregion############################## Actual Output #################################
					##region################################# Debug Output #################################
					inputChar='H'
					preDisplay+="$(tput setab "${TPUT_COLOR[BLUE]}")"
					postDisplay+="$RESET_COLOR_BACKGROUND"
					_addToOutput
					##endregion############################## Debug Output #################################
					break
				elif  [ "${CTR_SEQ[end]}" = $'\e'"$escapeSequence" ]; then
					# TODO: Implement
					##region################################# Debug Output #################################
					inputChar='E'
					preDisplay+="$(tput setab "${TPUT_COLOR[BLUE]}")"
					postDisplay+="$RESET_COLOR_BACKGROUND"
					_addToOutput
					##endregion############################## Debug Output #################################
					break
				elif  [ "${CTR_SEQ[left]}" = $'\e'"$escapeSequence" ]; then
					# TODO: allow non-destructive scroll-back
					##region################################# Debug Output #################################
					inputChar='L'
					preDisplay+="$(tput setab "${TPUT_COLOR[BLUE]}")"
					postDisplay+="$RESET_COLOR_BACKGROUND"
					visualAddToOutput
					##endregion############################## Debug Output #################################
					logicalScrollLeft
					break
				fi
			done
			# If 
			if ((iEsc <= 0)); then invalidCharacter; fi
			unset escapeSequence iEsc
		elif [[ "$inputChar" =~ ^[[:print:]]$ ]]; then # Incorrect character
			preDisplay+="${TPUT_COLOR[RED]}"
			setInputColor 1
			if [ "$inputChar" = ' ' ]; then
				preDisplay+="$(tput smso)"
				postDisplay="$(tput rmso)$postDisplay"
				inputChar="_"
			fi
			_addToOutput
		else
			invalidCharacter
		fi
		if ((currTime - lastUpdate > REFRESH_INTERVAL)); then
			##region########################################### Status Line ###########################################
			local preStatusLine="$(tput cud $((rows * 2 - currRow * 2)))"
			local statusLine=$'\r'
			__addLine() { statusLine+="$1$(tput el)"$' \b\n'; }
			IFS=$'\n'; __addLine "inputs: ${inputs[*]}"; IFS="$ORIG_IFS"
			# __addLine "inputColorsBg: ${inputColorsBg[*]@A}"
			# __addLine "inputColors: ${inputColors[*]}"
			# __addLine "removeCharacterAt($currRow, $(getCurrInputColNum)): $(removeCharacterAt $currRow "$(getCurrInputColNum)")"
			# __addLine "removeCharacterAt($((currRow - 1)), $(getInputColNum $((currRow - 1)))): $(removeCharacterAt $currRow "$(getInputColNum $((currRow - 1)))")"
			__addLine "_getXY: $(_getXY)"
			__addLine "_getXYPrior: $(_getXYPrior)"
			__addLine "_getXYBeforePrior: $(_getXYBeforePrior)"
			__addLine "getCoord: $(getCoord)"
			__addLine "getForPrior getCoord: $(getForPrior getCoord)"
			__addLine "getForBeforePrior getCoord: $(getForBeforePrior getCoord)"
			# shellcheck disable=SC2119
			__addLine "getInputColor: $(getInputColor)"
			__addLine "getForPrior 'getInputColor': $(getForPrior 'getInputColor')"
			__addLine "getForBeforePrior 'getInputColor': $(getForBeforePrior 'getInputColor')"
			# # shellcheck disable=SC2119
			# __addLine "getInputColorBg: $(getInputColorBg)"
			# __addLine "getForPrior 'getInputColorBg': $(getForPrior 'getInputColorBg')"
			# __addLine "getForBeforePrior 'getInputColorBg': $(getForBeforePrior 'getInputColorBg')"
			# shellcheck disable=SC2119
			__addLine "getInput: $(getInput)"
			__addLine "getForPrior 'getInput': $(getForPrior 'getInput')"
			__addLine "getForBeforePrior 'getInput': $(getForBeforePrior 'getInput')"
			__addLine "badInputs (Length: ${#badInputs}): $badInputs"
			# if ((${#words[@]} > 0)); then __addLine "last word: ${words[-1]}"; fi
			local postStatusLine="$(tput vpa $((currRow * 2 + 1)))"
			if (($(getCurrInputColNum) > 0)); then postStatusLine+="$(tput cuf "$(getCurrInputColNum)")"; fi
			echo -n "$preStatusLine$statusLine$postStatusLine"
			unset statusLine preStatusLine postStatusLine __addLine
			##endregion######################################## Status Line ###########################################
			((lastUpdate=currTime))
		fi
	done
}
while ((currRow < rows)); do _update; done
tput rmcup