#!/usr/bin/env bash

##region########################################### HELP & VERSION ###########################################
_show_help() {
	cat << __EOF__
Finds the location in the list of the specified value, or -1 if not in the list.

Usage:	$0 [-lf] [--] VALUE ENTRY1 ENTRY2...
	or:	$0 --value VALUE [-lf] [--] ENTRY1 ENTRY2...
	or:	$0 [--last|first] [--] VALUE ENTRY1 ENTRY2...
	or:	$0 --help
	or:	$0 --version

Options:
	-h, --help: Shows this help text.
	--version: Shows version info.
	-v, --value VALUE: The value to find the index of. Can be an empty string.
	-f, --first, --forward[s]: Search from the beginning of the list. Mutually exclusive with -l. Default.
	-l, --last, -b, --backward[s]: Search from the end of the list. Mutually exclusive with -f.
	-r, --regex: Treat 'VALUE' as an extended regex.
	-i, --invert: Instead of searching for matching values, searches for non-matching values. Mainly useful for filtering a list into matching and non-matching members.
	-a, --all: Find all matching indexes. Indices will be listed forwards unless '--last' is used; this will print from last to first. The output will be space-separated and end w/ a newline.
	--: Stop processing arguments. If 'VALUE' isn't assigned to yet, the next token will be used.

Exit Status:
	0 if found, 1 if not found, 255 for undefined execution error.
__EOF__
}
_show_version() {
	cat << __EOF__
$0 1.1.0

Copyright (C) 2025 Justin Morris
__EOF__
}
##endregion######################################## HELP & VERSION ###########################################

# TODO: Non-zero-based Index
# TODO: All Indices
declare fRegex='false'
declare fAll='false'
declare fLast='false'
declare fInvert='false'
declare value=''; unset value
shopt -s extglob
while [[ "$1" =~ ^- ]]; do
	case "$1" in
		(-h | --help) _show_help; exit 0;;
		(--version) _show_version; exit 0;;
		(-v | --value)
			shift
			declare -r value="$1"
			;;
		(-r | --regex) declare -r fRegex='true';;
		(-l | --last | -b | --backward | --backwards) declare -r fLast='true';;
		(-f | --first | --forward | --forwards) declare -r fLast='false';;
		(-a | --all) declare -r fAll='true';;
		(-i | --invert) declare -r fInvert='true';;
		(--)
			shift
			break
			;;
		(*)
			if ! [[ -v value ]]; then
				declare -r value="$1"
				shift
			fi
			break
			;;
	esac
	shift
done

# If value isn't readonly, assign to it and try to shift; if that fails...
if declare -r value="$1" &>'/dev/null' && ! shift; then
	echo "No array elements" 1>&2
	exit 255
fi
declare -a result=()
function _regexMatch() { if eval "$fInvert"; then ! [[ "$1" =~ $value ]] && return 0 || return 1; else [[ "$1" =~ $value ]] && return 0 || return 1; fi }
	function _literalMatch() { if eval "$fInvert"; then ! [ "$1" = "$value" ] && return 0 || return 1; else [ "$1" = "$value" ] && return 0 || return 1; fi }
if eval $fLast; then
	for ((i = $#; i > 0; i--)); do
		if (eval "$fRegex" && _regexMatch "${!i}") ||
			(! eval "$fRegex" && _literalMatch "${!i}"); then
			if ! eval "$fAll"; then
				echo "$((i - 1))"
				exit 0
			else
				result+=("$((i - 1))")
			fi
		fi
	done
else
	for ((i = 1; i <= $#; i++)); do
		if (eval "$fRegex" && _regexMatch "${!i}") ||
			(! eval "$fRegex" && _literalMatch "${!i}"); then
			if ! eval "$fAll"; then
				echo "$((i - 1))"
				exit 0
			else
				result+=("$((i - 1))")
			fi
		fi
	done
fi

if ((${#result[@]} != 0)); then
	echo "${result[*]}"
	exit 0
else
	echo "-1"
	exit 1
fi