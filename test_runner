#!/usr/bin/env bash

readonly MY_PATH=$(realpath "$0")
# echo "$MY_PATH"
MY_DIR=""
if [[ "$MY_PATH" =~ ^(.*)/[^/]+$ ]]; then
	readonly MY_DIR="${BASH_REMATCH[1]}"
else
	MY_DIR="Failed to get dir"
fi
# echo "$MY_DIR"
declare -r DEFAULT_TEST_CASES_DIRECTORY="$MY_DIR/test/"
declare -r DEFAULT_TEST_CASES_SUFFIX="_test_cases"
declare -r DEFAULT_TEST_CASES_EXTENSION=".txt"
show_help() {
	# or:	$0 [-c COARSENESS] [-d SEPARATOR] NUMERATOR DENOMINATOR
	# -c, --coarseness COARSENESS: precision. Defaults to $DEFAULT_COARSENESS.
	# -d, --decimal SEPARATOR: the fractional separator. Defaults to $DEFAULT_DECIMAL
	cat << __EOF__
Run tests for simple scripts

Usage:	$0 COMMAND [PATH [NAME]]
	or:	$0 --help
	or:	$0 --version

Options:
	-h, --help: Shows this help text.
	-v, --version: Shows version info.
__EOF__
}
show_version() {
	cat << __EOF__
$0 1.0.0

Copyright (C) 2025 Justin Morris
__EOF__
}
declare testPath="$DEFAULT_TEST_CASES_DIRECTORY"
declare testFile=''
declare testCommand=''
declare -n opt1=testCommand opt2=testPath opt3=testFile
while [[ -n "${1+x}" ]]; do
	case "$1" in
		(-h | --help)
			show_help
			exit
			;;
		(-v | --version)
			show_version
			exit
			;;
		# (-c | --coarseness)
		# 	shift
		# 	coarseInput="$1"
		# 	shift
		# 	;;
		# (-d | --decimal)
		# 	shift
		# 	separator="$1"
		# 	shift
		# 	;;
		(*)
			if [[ -n "$opt1" ]]; then
				if [[ -n "$opt2" ]]; then
					if [[ -n "$opt3" ]]; then
						exit 1
					else
						opt3="$1"
					fi
				else
					opt2="$1"
				fi
			else
				opt1="$1"
			fi
			shift
			;;
	esac
done

# echo "testCommand: $testCommand testFile: $testFile testPath: $testPath"
if (( ${#testFile} == 0 )); then
	declare -r testFile="$testCommand"
fi
if (( ${#testPath} == 0 )); then
	if [ -f "$testFile" ]; then
		declare -r testPath="$testFile"
	elif [ -f "$testFile$DEFAULT_TEST_CASES_SUFFIX" ]; then
		declare -r testPath="$testFile$DEFAULT_TEST_CASES_SUFFIX"
	elif [ -f "$testFile$DEFAULT_TEST_CASES_SUFFIX$DEFAULT_TEST_CASES_EXTENSION" ]; then
		declare -r testPath="$testFile$DEFAULT_TEST_CASES_SUFFIX$DEFAULT_TEST_CASES_EXTENSION"
	elif [ -f "$DEFAULT_TEST_CASES_DIRECTORY$testFile" ]; then
		declare -r testPath="$DEFAULT_TEST_CASES_DIRECTORY$testFile"
	elif [ -f "$DEFAULT_TEST_CASES_DIRECTORY$testFile$DEFAULT_TEST_CASES_SUFFIX" ]; then
		declare -r testPath="$DEFAULT_TEST_CASES_DIRECTORY$testFile$DEFAULT_TEST_CASES_SUFFIX"
	elif [ -f "$DEFAULT_TEST_CASES_DIRECTORY$testFile$DEFAULT_TEST_CASES_SUFFIX$DEFAULT_TEST_CASES_EXTENSION" ]; then
		declare -r testPath="$DEFAULT_TEST_CASES_DIRECTORY$testFile$DEFAULT_TEST_CASES_SUFFIX$DEFAULT_TEST_CASES_EXTENSION"
	else
		echo "Can't find test file '$testFile'" 1>&2
		exit 1
	fi
else
	testPath+="$testFile"
	if [ -f "$testPath" ]; then
		declare -r testPath
	elif [ -f "$testPath$DEFAULT_TEST_CASES_SUFFIX" ]; then
		declare -r testPath="$testPath$DEFAULT_TEST_CASES_SUFFIX"
	elif [ -f "$testPath$DEFAULT_TEST_CASES_SUFFIX$DEFAULT_TEST_CASES_EXTENSION" ]; then
		declare -r testPath="$testPath$DEFAULT_TEST_CASES_SUFFIX$DEFAULT_TEST_CASES_EXTENSION"
	elif [ -f "$DEFAULT_TEST_CASES_DIRECTORY$testPath" ]; then
		declare -r testPath="$DEFAULT_TEST_CASES_DIRECTORY$testPath"
	elif [ -f "$DEFAULT_TEST_CASES_DIRECTORY$testPath$DEFAULT_TEST_CASES_SUFFIX" ]; then
		declare -r testPath="$DEFAULT_TEST_CASES_DIRECTORY$testPath$DEFAULT_TEST_CASES_SUFFIX"
	elif [ -f "$DEFAULT_TEST_CASES_DIRECTORY$testPath$DEFAULT_TEST_CASES_SUFFIX$DEFAULT_TEST_CASES_EXTENSION" ]; then
		declare -r testPath="$DEFAULT_TEST_CASES_DIRECTORY$testPath$DEFAULT_TEST_CASES_SUFFIX$DEFAULT_TEST_CASES_EXTENSION"
	else
		echo "Can't find test file '$testPath'" 1>&2
		exit 1
	fi
fi
# echo "testCommand: $testCommand testFile: $testFile testPath: $testPath"

declare -r ORIG_IFS="$IFS"
declare -A TESTS=()
declare -a TEST_ORDER=()
declare -A TEST_LABELS=()
do_read() {
	local params=''
	local results=''
	local label=''
	while read -s -t 0; do
		read -sr params results
		# echo "P: $params, R: $results"
		if (( ${#params} <= 0 && ${#results} <= 0 )); then
			break
		elif (( ${#params} <= 0 || ${#results} <= 0 )); then
			label+="$params"
			label+=$'\n'
			continue
		fi
		# if [[ "$params" =~ /$ ]]; then params="${params:0:-1}"; fi
		# if [[ "$results" =~ /$ ]]; then results="${results:0:-1}"; fi
		TEST_ORDER+=("$params")
		TESTS[$params]="$results"
		TEST_LABELS[$params]="$label"
		label=''
	done
	# echo $?
	return
}
IFS=$'>'
do_read < "$testPath"
IFS="$ORIG_IFS"
succeeded='true'
echo -n $'\n\n# Running:\n\n'
# for params in "${!TESTS[@]}"; do
for params in "${TEST_ORDER[@]}"; do
	# shellcheck disable=SC2086
	output="$(decimal_calc $params)"
	if [ "$output" != "${TESTS[$params]}" ]; then
		echo "$(tput setaf 1)F$(tput setaf 7)"
		echo "${TEST_LABELS[$params]}decimal_calc $params: Result ($output) != Expected (${TESTS[$params]})" 1>&2
		succeeded='false'
	else
		echo -n "$(tput setaf 2).$(tput setaf 7)"
	fi
done
echo -n $'\n\n'
echo "Succeeded: $succeeded"
eval $succeeded
exit $?