#!/usr/bin/env bash

if [ "$1" = '--help' ]; then
	exit 1
elif [ "$1" = '--version' ]; then
	exit 1
fi
set -e
declare -r numericMatcher='^[-+]?[[:digit:]]+$'
declare fInvert='false'
declare fAll='false'
declare fAt='false'
declare fRegex='false'
# declare toRemove
declare delim=$'\n' # declare delim=$'\003'
# declare eot=$'\n' # declare delim=$'\003'
shopt -s extglob globasciiranges
while true; do
	case "$1" in
		-d | --delim) shift; declare -r delim="$1";;
		-s | --single | -o | --one) declare -r fAll='false';;
		-a | --all) declare -r fAll='true';;
		--invert) declare -r fInvert='true';;
		-r | --regex) declare -r fRegex='true';;
		-i | --index | --at | --at[-_]index)
			declare -r fAt='true'
			if ! [ -v toRemove ] && [[ "$2" =~ $numericMatcher ]]; then
				shift
				declare toRemove="$1"
			fi
			;;
		*)
			if ! [ -v toRemove ]; then
				declare toRemove="$1"
				if ! shift; then
					echo "No array elements" 1>&2
					exit 1
				fi
			fi
			break
			;;
	esac
	shift
done
if ! [ -v toRemove ]; then
	echo "toRemove Undefined" 1>&2
	exit 1
fi
declare -r toRemove="$toRemove" fAll fAt delim fRegex fInvert
declare -a result=()
if eval "$fAt"; then
	# TODO: account for octal & such https://www.gnu.org/software/bash/manual/bash.html#Shell-Arithmetic
	if ! [[ "$toRemove" =~ $numericMatcher ]]; then
		echo "Cannot remove non-numeric index $toRemove" 1>&2
		exit 1
	else
		declare -i toRemove # If octal or whatever, fixes it for upcoming error messages
		if ((toRemove >= $#)); then
			echo "Cannot remove index $toRemove that exceeds array length of $#" 1>&2
			exit 1
		elif ((toRemove < 0 && toRemove * 1 >= $#)); then
			echo "Cannot remove negative index $toRemove that exceeds array length of $#" 1>&2
			exit 1
		fi
	fi
	result=("$@")
	unset "result[$toRemove]"
	# result=("${result[@]}") # Fixes indices
else
	function _regexMatch() { if eval "$fInvert"; then ! [[ "$1" =~ $toRemove ]] && return 0 || return 1; else [[ "$1" =~ $toRemove ]] && return 0 || return 1; fi }
	function _literalMatch() { if eval "$fInvert"; then ! [ "$1" = "$toRemove" ] && return 0 || return 1; else [ "$1" = "$toRemove" ] && return 0 || return 1; fi }
	while (($# > 0)); do
		if (eval "$fRegex" && _regexMatch "$1") ||
			(! eval "$fRegex" && _literalMatch "$1"); then
			if eval "$fAll"; then
				shift
				continue
			fi
			if shift; then
				result+=("$@")
			fi
			break
		fi
		result+=("$1")
		shift
	done
fi
IFS="$delim"
echo -nE "${result[*]}$delim"
exit