#!/usr/bin/env bash

declare -ri DEFAULT_COARSENESS=100
declare -r DEFAULT_DECIMAL='.'
show_help() {
	cat << __EOF__
Print the result of the given division operation with the specified precision, trimming trailing zeros and rounding excess.

Usage:	$0 NUMERATOR DENOMINATOR [COARSENESS SEPARATOR]
	or:	$0 [-c COARSENESS] [-d SEPARATOR] NUMERATOR DENOMINATOR
	or:	$0 --help
	or:	$0 --version

Options:
	-c, --coarseness COARSENESS: precision. Defaults to $DEFAULT_COARSENESS.
	-d, --decimal SEPARATOR: the fractional separator. Defaults to $DEFAULT_DECIMAL
	-h, --help: Shows this help text.
	-v, --version: Shows version info.
__EOF__
}
show_version() {
	cat << __EOF__
$0 2.0.0

Copyright (C) 2025 Justin Morris
__EOF__
}
declare -i numerator=0; unset numerator
declare -i denominator=0; unset denominator
declare coarseInput # ="${coarseInput:-100}"
declare separator='.'
while [[ -n "${1+x}" ]]; do
	case "$1" in
		(-h | --help)
			show_help
			exit
			;;
		(-v | --version)
			show_version
			exit
			;;
		(-c | --coarseness)
			shift
			coarseInput="$1"
			shift
			;;
		(-d | --decimal)
			shift
			separator="$1"
			shift
			;;
		(*)
			if [[ -n "${numerator+x}" ]]; then
				if [[ -n "${denominator+x}" ]]; then
					if [[ -n "${coarseInput+x}" ]]; then
						exit 1
					else
						coarseInput="$1"
					fi
				else
					((denominator = $1))
				fi
			else
				((numerator = $1))
			fi
			shift
			;;
	esac
done

declare -ir numerator
declare -ir denominator
if ((denominator==0)); then
	echo -n "Divide by zero error: $numerator / $denominator" 1>&2
	exit 1
fi
declare -i whole=numerator/denominator
if (( numerator % denominator == 0 )); then
	echo -n "$whole"
	exit
fi
declare -r coarseInput="${coarseInput:-$DEFAULT_COARSENESS}"
declare -ir decimalDigits="${#coarseInput}"
declare -ir coarseness="$((10 ** decimalDigits))"
if ((coarseness==1)); then
	echo -n "$whole"
	exit
fi
declare -i l_intermediate=0; ((l_intermediate=numerator * coarseness / denominator, whole_count=${#whole})); 
declare +i l_intermediate
if ((whole_count > 1 || whole != 0)); then l_intermediate="${l_intermediate:$whole_count}"; fi
while [[ "${l_intermediate: -1}" == '0' ]] && ((${#l_intermediate} > 1)); do l_intermediate="${l_intermediate:0:-1}"; done
if (( ${#l_intermediate} >= decimalDigits )); then
	declare penultimate="${l_intermediate: -2:1}" last="${l_intermediate: -1:1}"; l_intermediate="${l_intermediate:0:-2}"
	if ((last<5)); then
		while [[ "$penultimate" == '0' ]] && ((${#l_intermediate} > 0)); do 
			penultimate="${l_intermediate: -1}"
			l_intermediate="${l_intermediate:0:-1}"
		done
		if [ "$penultimate" = '0' ]; then
			echo -n "$whole"
		else
			echo -n "$whole$separator$l_intermediate$penultimate"
		fi
	else
		while ((penultimate == 9 && ${#l_intermediate} > 0)); do
			penultimate="${l_intermediate: -1}"
			l_intermediate="${l_intermediate:0:-1}"
		done
		if ((penultimate < 9)); then
			echo -n "$whole$separator$l_intermediate$((penultimate+1))"
		elif ((${#l_intermediate} > 0)); then
			echo -n "$whole$separator$l_intermediate"
		else
			((i=${#whole}-1))
			l_intermediate="${whole:$i:1}"
			while ((i >= 0 && ${whole:$i:1} == 9 && ${#l_intermediate} > 0)); do
				l_intermediate="${whole:$i:1}"
				whole="${whole:0:$i}0${whole:$((i+1))}"
				((i--))
			done
			if ((i < 0 && ${whole:0:1} == 9)); then
				echo -n "1$whole"
			else
				echo -n "${whole:0:$i}$((${whole:$i:1} + 1))${whole:$((i+1))}"
			fi
		fi
	fi
else
	echo -n "$whole$separator${l_intermediate:0:$decimalDigits}"
fi

exit
