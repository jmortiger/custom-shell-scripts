#!/usr/bin/env bash

# cspell:ignore ilos OVERRIDERS extglob
readonly C_OUTPUT_ROWS='ROWS'
readonly C_OUTPUT_MAX_COLS='MAX_COLUMNS'
readonly C_OUTPUT_COLS_AT='COLUMNS_AT'
readonly C_OUTPUT_ROW_AT='ROW_AT'
readonly C_OUTPUT_COLS_AT_REGEX='^[[:digit:]]+$|^_$'
readonly NL_PATTERN='[^[:print:][:blank:]]'
readonly NON_NL_PATTERN='[[:print:][:blank:]]'
readonly C_TRAILING_CTRL_OVERRIDERS='^-[mc]$|^--(max_col|col_at)$'
# TODO: Output multiple
# #region show_help
show_help() {
	cat <<- __EOF__
	profile_text - Retrieve statistics about the input text.

	profile_text [OPTIONS] TEXT | profile_text -h | profile_text --help
	
	Retrieve statistics about the input text.
	
	Parameters:
		Output:
	    	-h | --help: Display this help text.
			-r | --rows: get the total number of rows
			-c | --col_at INDEX: Get the # of columns on the specified row INDEX (or, if '_', the last index). By default, turns off appending control characters (See '--no_trailing_control').
			-m | --max_col: Get the maximum number of columns (i.e characters) in any row. By default, turns off appending control characters (See '--no_trailing_control').
			--row_at INDEX: Get the text on the row specified by INDEX (or, if '_', the last index).
		Settings:
			--initial_column_offset: The starting horizontal position of the cursor. Defaults to 0.
			--no_trailing_control: don't append control characters to the lines they end.
			--trailing_control: do append control characters to the lines they end.
			--output_columns: The number of characters permitted in each line of the output. Defaults to 'tput cols'.
			--output_rows: The number of lines of text in the output's view. Excess output will be handled with vertical overflow. Defaults to 'tput lines'.
	EXIT STATUS:
		0 if successful
	__EOF__
}
# #endregion show_help

readonly ORIG_IFS=$IFS
# #region PARAMS
# TODO: Add option - Remove lines overwritten due to being preceded by \r?
allow_continue='true'
shopt -s 'extglob'
# readonly extglob_off=$( if [[ $(shopt extglob) =~ on$ ]]; then echo 'false'; else echo 'true'; fi )
# if eval $extglob_off; then
# 	shopt -s 'extglob'
# fi
declare p_trailing_control_chars='true'
declare -i TERM_COLS=$(tput cols) TERM_ROWS=$(tput lines)
declare -i initial_line_offset=0 initial_line_offset_unwrapped=0
declare flagTrackRows='false' flagTrackUnwrapped='false'
while (( $# > 1 )) && eval $allow_continue; do
	case "$1" in
		( -h | --help )
			show_help
			exit 0
			;;
		( --output_columns )
			shift
			if [[ "$1" =~ ^[123456789]+[[:digit:]]*$ ]]; then
		    	declare -r -g -i TERM_COLS="$1"
				if [ ! $? ]; then exit 1; fi
			# elif [ "$1" = '_' ]; then :; # index is last entry
			else
				echo "output_columns must be a positive integer; value was '$1'"
            	show_help
            	exit 1
			fi
			;;&
		( --output_rows )
			shift
			if [[ "$1" =~ ^[123456789]+[[:digit:]]*$ ]]; then
		    	declare -r -g -i TERM_ROWS="$1"
				if [ ! $? ]; then exit 1; fi
			# elif [ "$1" = '_' ]; then :; # index is last entry
			else
				echo "output_rows must be a positive integer; value was '$1'"
            	show_help
            	exit 1
			fi
			;;&
		( --initial_column_offset )
			shift
			if [[ "$1" =~ ^[[:digit:]]+$ ]]; then
		    	declare -g -i initial_line_offset="$1" initial_line_offset_unwrapped="$1"
				if [ ! $? ]; then exit 1; fi
			# elif [ "$1" = '_' ]; then :; # index is last entry
			else
				echo "initial_column_offset must be a non-negative integer; value was '$1'"
            	show_help
            	exit 1
			fi
			;;&
		( --no_trailing_control )
			declare -r p_trailing_control_chars='false'
			if [ ! $? ]; then exit 1; fi
			;;&
		( --trailing_control )
			declare -r p_trailing_control_chars='true'
			if [ ! $? ]; then exit 1; fi
			;;&
		( -r | --rows )
			declare -r p_output=$C_OUTPUT_ROWS
			if [ ! $? ]; then exit 1; fi
			;;&
		( -m | --max_col )
			declare -r p_output=$C_OUTPUT_MAX_COLS
			if [ ! $? ]; then exit 1; fi
			if ! declare -p p_trailing_control_chars | grep -q -P -e '-r' -; then
				p_trailing_control_chars='false'
			fi
			;;&
		( -c | --col_at )
			declare -r p_output=$C_OUTPUT_COLS_AT
			if [ ! $? ]; then exit 1; fi
			if ! declare -p p_trailing_control_chars | grep -q -P -e '-r' -; then
				p_trailing_control_chars='false'
			fi
			shift
			if [[ "$1" =~ ^[[:digit:]]+$ ]]; then
		    	declare -r -g -i p_index="$1"
				if [ ! $? ]; then exit 1; fi
			elif [ "$1" = '_' ]; then :; # index is last entry
			else
				echo "col_at must be a non-negative integer or a _; value was '$1'"
            	show_help
            	exit 1
			fi
			;;&
		( --row_at )
			declare -r p_output=$C_OUTPUT_ROW_AT
			if [ ! $? ]; then exit 1; fi
			shift
			if [[ "$1" =~ ^[[:digit:]]+$ ]]; then
		    	declare -r -g -i p_index="$1"
				if [ ! $? ]; then exit 1; fi
			elif [ "$1" = '_' ]; then :; # index is last entry
			else
				echo "row_at must be a non-negative integer or a _; value was '$1'"
            	show_help
            	exit 1
			fi
			;;&
		( -[[:alpha:]] | --+([[:alpha:]_]) )
			# echo "Gen called"
			shift
			;;
		( ^--$ )
			# echo -n "Premature "
			shift
			;&
		( * )
			# echo "end called"
			allow_continue='false'
			;;
	esac
done
# echo "Out of param loop"
if [[ -z "${p_output+SET}" ]]; then declare -r p_output=$C_OUTPUT_ROWS; fi
# #endregion PARAMS

readonly text="$*"

declare -r -i C_LENGTH=${#text}

# declare -r -i TERM_COLS=$(tput cols) TERM_ROWS=$(tput lines)

declare -i c_rows=1 c_rows_unwrapped=1

# TODO: Finish unwrapped stuff
declare -a rows=("") # rows_unwrapped=("")
# declare -i initial_line_offset=0 initial_line_offset_unwrapped=0
declare -a row_ilos=([0]=$initial_line_offset) # row_ilos_unwrapped=([0]=$initial_line_offset_unwrapped) # TODO: TRACK ROWS
declare -i char_offset=0 trailing_count=0
declare uninterrupted_line="" # uninterrupted_line_unwrapped=""
declare -i max_col=-1
declare -i last_remainder=-1
# echo "Length: ${#text}"
while ((char_offset < ${#text})); do
	# echo "${#rows[@]}"
	# echo "c_rows at loop start: $c_rows"
	text_segment=${text:char_offset}
	if [[ $text_segment =~ ^($NON_NL_PATTERN*)($NL_PATTERN) ]]; then
		# echo -n "char_offset: $char_offset -> "
		((char_offset+=${#BASH_REMATCH[0]}))
		# echo "$char_offset"
		# echo "matched ${BASH_REMATCH[*]}"
		uninterrupted_line=${BASH_REMATCH[1]}
		new_line=${BASH_REMATCH[2]}
	else
		# echo -n "char_offset: $char_offset -> "
		((char_offset+=${#text_segment}))
		# echo "$char_offset"
		uninterrupted_line=$text_segment
		unset new_line
	fi
	# #region TODO: FINISH SAFETY CHECK
	# TODO: FINISH SAFETY CHECK
	# ((t=${#text_segment}+char_offset, new_remainder=${#text}-t))
	# if (( last_remainder < 0 )); then
	# 	((last_remainder=new_remainder))
	# elif (( last_remainder > 0 && last_remainder !=  ))
	# fi
	# #endregion TODO: FINISH SAFETY CHECK
	# uninterrupted_line_unwrapped=$uninterrupted_line
	# ((initial_line_offset_unwrapped+=${#uninterrupted_line}))
	# ((initial_line_offset+=${#uninterrupted_line}, t=initial_line_offset%TERM_COLS>0?initial_line_offset:initial_line_offset-1, c_rows+=t/TERM_COLS))
	((t_eol=TERM_COLS-initial_line_offset, initial_line_offset+=${#uninterrupted_line}))
	for ((t_off=0, t_inc=1; ${#uninterrupted_line}-t_off > 0; t_off+=t_eol, t_eol=TERM_COLS, c_rows+=t_inc)); do
		if ((t_off + t_eol > ${#uninterrupted_line})); then
			t_l="${uninterrupted_line:t_off}"
			((t_inc=0))
		else
			t_l="${uninterrupted_line:t_off:t_eol}"
			((t_inc=1))
		fi
		# echo "c_rows: $c_rows rows.length: ${#rows[@]} $t_l"
		rows[-1]+="$t_l"
		rows+=("")
		# echo "${rows[-1]}"
		# echo "rows.length: ${#rows[@]}"
		((max_col = max_col < ${#t_l} ? ${#t_l} : max_col))
	done
	# echo -n "Line: $uninterrupted_line; rows.length: ${#rows[@]}"
	if [[ -z "$uninterrupted_line" ]]; then rows+=(""); fi
	# echo "-> ${#rows[@]}"
	# echo "c_rows before: $c_rows"
	if [[ -n "${new_line+x}" ]]; then
		# echo -n "newline="
		if [[ $new_line == $'\v' ]]; then
			# echo '\v'
			if eval $p_trailing_control_chars; then rows[-2]+="$new_line"; fi # rows+=("$new_line")
			((c_rows+=1, c_rows_unwrapped+=1)) # For the new line
			((initial_line_offset%=TERM_COLS))
		elif [[ $new_line == $'\f' ]]; then
			# echo '\f'
			if eval $p_trailing_control_chars; then rows[-2]+="$new_line"; fi # rows+=("$new_line")
			((c_rows+=1, c_rows_unwrapped+=1)) # For the new line
			((initial_line_offset%=TERM_COLS))
		elif [[ $new_line == $'\r' ]]; then # TODO: Check if CR on wrapped line will return to start of wrapped line or unwrapped line
			# echo '\r'
			if eval $p_trailing_control_chars; then rows[-2]+="$new_line"; fi
			unset 'rows[-1]'
			((trailing_count=initial_line_offset_unwrapped))
			((initial_line_offset=0, initial_line_offset_unwrapped=0))
		elif [[ $new_line == $'\n' ]]; then
			# echo '\n'
			if eval $p_trailing_control_chars; then rows[-2]+="$new_line"; fi # rows+=("$new_line")
			((c_rows+=1, c_rows_unwrapped+=1)) # For the new line
			((initial_line_offset=0, initial_line_offset_unwrapped=0))
		else
			# echo "idk, $new_line"
			if eval $p_trailing_control_chars; then rows[-2]+="$new_line"; fi # rows+=("$new_line")
			((c_rows+=1, c_rows_unwrapped+=1)) # For the new line
			((initial_line_offset=0, initial_line_offset_unwrapped=0))
		fi
	fi
	# echo "c_rows after: $c_rows"
done

# #region Returning
# declare -i i=0
# while ((i<${#param[@]})); do
# 	case "${param[i]}" in
# 		-r | --rows)
# 			echo -n $c_rows
# 			break
# 			;;
# 		*)
# 			;;
# 	esac
# 	((i++))
# done
case "$p_output" in
	("$C_OUTPUT_MAX_COLS")
		echo $max_col
		;;
	("$C_OUTPUT_COLS_AT")
		if [[ -z "${p_index+x}" ]]; then ((p_index=${#rows}-1)); fi
		echo "${#rows[$p_index]}"
		;;
	("$C_OUTPUT_ROW_AT")
		if [[ -z "${p_index+x}" ]]; then ((p_index=${#rows}-1)); fi
		# echo "$p_index"
		# IFS=$'\0'; echo "${rows[*]}"; IFS="$ORIG_IFS"
		echo "${rows[$p_index]}"
		;;
	("$C_OUTPUT_ROWS") ;&
	(*)
		echo $c_rows
		;;
esac
exit
# #endregion Returning